# This file was generated. Do not edit manually.

schema {
    query: Query
    subscription: Subscription
}

"creates a virtual field on the entity that may be queried but cannot be set manually through the mappings API."
directive @derivedFrom(field: String!) on FIELD_DEFINITION

"Marks the GraphQL type as indexable entity.  Each type that should be an entity is required to be annotated with this directive."
directive @entity on OBJECT

"Defined a Subgraph ID for an object type"
directive @subgraphId(id: String!) on OBJECT

type Account {
    address: String!
    createdAt: BigInt!
    currencies(first: Int = 100, orderBy: CurrencyBalance_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: CurrencyBalance_filter): [CurrencyBalance!]
    events(first: Int = 100, orderBy: Event_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Event_filter): [Event!]
    gameItems(first: Int = 100, orderBy: GameItemBalance_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: GameItemBalance_filter): [GameItemBalance!]
    id: ID!
    nfts(first: Int = 100, orderBy: NFT_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: NFT_filter): [NFT!]
    operatorAccounts(first: Int = 100, orderBy: OperatorAccount_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: OperatorAccount_filter): [OperatorAccount!]!
    questData: AccountQuestData
    recipeData: AccountRecipeData
    worldEntity: WorldEntity
}

type AccountQuestData {
    account: Account!
    completed: Int!
    failed: Int!
    id: ID!
    lastCompletionTime: BigInt!
    quest: Quest!
    started: Int!
    succeeded: Int!
}

type AccountRecipeData {
    account: Account!
    completed: Int!
    failed: Int!
    id: ID!
    lastCompletionTime: BigInt!
    quest: Quest!
    started: Int!
    succeeded: Int!
}

type ActiveQuest {
    id: ID!
    nft: NFT
    nfts(first: Int = 100, orderBy: NFT_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: NFT_filter): [NFT!]!
    quest: Quest!
}

type BossBattleResult {
    account: Account
    bossEntity: BigInt!
    bossTokenTemplate: TokenTemplate
    createdAt: BigInt!
    damageDealt: BigInt!
    damageTaken: BigInt!
    id: ID!
    isFinalBlow: Boolean!
    shipEntity: BigInt!
    shipNft: NFT
}

type Component {
    contract: Contract
    entities(first: Int = 100, orderBy: WorldEntityComponentValue_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: WorldEntityComponentValue_filter): [WorldEntityComponentValue!]!
    id: ID!
    name: String
    schema(first: Int = 100, orderBy: ComponentSchemaField_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: ComponentSchemaField_filter): [ComponentSchemaField!]!
    worldEntity: WorldEntity
}

type ComponentFieldValue {
    componentValue: WorldEntityComponentValue!
    fieldIndex: Int!
    id: ID!
    name: String!
    value: String!
    worldEntity: WorldEntity
}

type ComponentSchemaField {
    fieldIndex: Int!
    id: ID!
    name: String!
    type: Int
}

type Contract {
    address: String!
    createdAt: BigInt
    createdBlock: BigInt
    holdingMilestones(first: Int = 100, orderBy: HoldingMilestone_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: HoldingMilestone_filter): [HoldingMilestone!]
    id: ID!
    name: String
    owner: Account
    paused: Boolean!
    symbol: String
    type: ContractType
    uri: String
    worldEntity: WorldEntity
}

type CountData {
    entityAddress: String
    entityToken: BigInt
    id: ID!
    key: BigInt!
    packedEntity: BigInt!
    value: BigInt!
}

type Currency {
    balances(first: Int = 100, orderBy: CurrencyBalance_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: CurrencyBalance_filter): [CurrencyBalance!]
    contract: Contract!
    decimals: Int!
    id: ID!
    name: String!
    symbol: String!
    totalBurned: BigInt!
    totalMinted: BigInt!
    totalSupply: BigInt!
}

type CurrencyBalance {
    amount: BigInt!
    currency: Currency!
    id: ID!
    owner: Account!
    totalBurned: BigInt!
    totalMinted: BigInt!
}

type DungeonEnemy {
    contractAddress: String!
    createdAt: BigInt!
    id: ID!
    node: DungeonNode!
    tokenId: BigInt!
    tokenTemplate: TokenTemplate
}

type DungeonMap {
    contractAddress: String
    createdAt: BigInt!
    id: ID!
    nodes(first: Int = 100, orderBy: DungeonNode_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: DungeonNode_filter): [DungeonNode!]
    tokenId: BigInt
    triggers(first: Int = 100, orderBy: DungeonTrigger_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: DungeonTrigger_filter): [DungeonTrigger!]
}

type DungeonNode {
    createdAt: BigInt!
    enemies(first: Int = 100, orderBy: DungeonEnemy_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: DungeonEnemy_filter): [DungeonEnemy!]!
    id: ID!
    loots(first: Int = 100, orderBy: Loot_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Loot_filter): [Loot!]!
    map: DungeonMap!
}

type DungeonTrigger {
    contractAddress: String!
    createdAt: BigInt!
    endAt: BigInt!
    id: ID!
    map: DungeonMap!
    startAt: BigInt!
    tokenId: BigInt!
    tokenTemplate: TokenTemplate
}

type Event {
    account: Account!
    amount: BigInt
    contractAddress: String!
    createdAt: BigInt!
    currency: Currency
    from: Account
    gameItem: GameItem
    id: ID!
    name: String!
    nft: NFT
    quest: Quest
    recipeDefinition: RecipeDefinition
    relevantAccounts(first: Int = 100, orderBy: Account_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Account_filter): [Account!]!
    to: Account
    tokenId: BigInt
    transactionHash: String!
    type: EventType
    value: BigInt!
    worldEntity: WorldEntity
}

type GameGlobal {
    dataType: GameGlobalDataType!
    id: ID!
    name: String!
    value: String
}

type GameItem {
    actions(first: Int = 100, orderBy: TokenAction_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TokenAction_filter): [TokenAction!]
    animationUrl: String
    attributes(first: Int = 100, orderBy: TokenAttribute_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TokenAttribute_filter): [TokenAttribute!]
    burned: BigInt!
    contractAddress: String!
    currentSupply: BigInt!
    description: String
    events(first: Int = 100, orderBy: Event_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Event_filter): [Event!]
    externalUrl: String
    id: ID!
    iframeUrl: String
    imageUrl: String
    maxSupply: BigInt!
    minted: BigInt!
    modelGltfUrl: String
    name: String
    numOwners: BigInt!
    recyclable: Boolean!
    tags: String
    tokenId: BigInt!
    tokenTemplate: TokenTemplate
    traits(first: Int = 100, orderBy: TraitValue_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TraitValue_filter): [TraitValue!]
    worldEntity: WorldEntity
}

type GameItemBalance {
    amount: BigInt!
    gameItem: GameItem!
    id: ID!
    lockedAmount: BigInt!
    owner: Account!
}

type HoldingMilestone {
    id: ID!
    loots(first: Int = 100, orderBy: Loot_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Loot_filter): [Loot!]!
    milestoneIndex: Int!
    timeHeldSeconds: BigInt!
    tokenContract: Contract!
}

type Loot {
    amount: BigInt!
    id: ID!
    lootId: BigInt
    lootType: String!
    tokenContract: Contract
}

type LootSet {
    id: ID!
    loots(first: Int = 100, orderBy: Loot_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Loot_filter): [Loot!]!
}

type LootTable {
    id: ID!
    lootSets(first: Int = 100, orderBy: LootSet_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: LootSet_filter): [LootSet!]!
    maxSupply: [BigInt!]!
    mints: [BigInt!]!
    weights: [BigInt!]!
}

type NFT {
    actions(first: Int = 100, orderBy: TokenAction_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TokenAction_filter): [TokenAction!]
    animationUrl: String
    attributes(first: Int = 100, orderBy: TokenAttribute_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TokenAttribute_filter): [TokenAttribute!]
    claimedMilestones(first: Int = 100, orderBy: NFTClaimedMilestone_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: NFTClaimedMilestone_filter): [NFTClaimedMilestone!]
    contractAddress: String!
    description: String
    events(first: Int = 100, orderBy: Event_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Event_filter): [Event!]
    externalUrl: String
    id: ID!
    iframeUrl: String
    imagePng1024: String
    imagePng2048: String
    imagePng256: String
    imagePng512: String
    imageSvg: String
    imageUrl: String
    lastEarnTimestamp: BigInt
    lastEnergyAmount: BigInt
    lastEnergyEarnable: BigInt
    lastEnergySpendTimestamp: BigInt
    lastTransfer: BigInt
    locked: Boolean!
    minted: Boolean!
    modelGltfUrl: String
    name: String
    nftType: String
    owner: Account!
    tags: String
    tokenId: BigInt!
    tokenTemplate: TokenTemplate
    traits(first: Int = 100, orderBy: TraitValue_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TraitValue_filter): [TraitValue!]
    worldEntity: WorldEntity
}

type NFTClaimedMilestone {
    claimed: Boolean!
    claimedAt: BigInt
    holdingMilestone: HoldingMilestone!
    id: ID!
    milestoneIndex: Int!
    nft: NFT!
}

type OperatorAccount {
    address: String!
    expiration: BigInt!
    id: ID!
    playerAccount: Account!
}

type PirateStatsData {
    energyGained: BigInt!
    energySpent: BigInt!
    goldMinted: BigInt!
    id: ID!
    intervalStartAt: String!
    intervalType: StatsIntervalType!
    nft: NFT
    questsCompleted: Int!
    questsFailed: Int!
    questsStarted: Int!
    questsSucceeded: Int!
}

type Query {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    account(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Account
    accountQuestData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AccountQuestData
    accountQuestDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AccountQuestData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AccountQuestData_filter
    ): [AccountQuestData!]!
    accountRecipeData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AccountRecipeData
    accountRecipeDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AccountRecipeData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AccountRecipeData_filter
    ): [AccountRecipeData!]!
    accounts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Account_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Account_filter
    ): [Account!]!
    activeQuest(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ActiveQuest
    activeQuests(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ActiveQuest_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ActiveQuest_filter
    ): [ActiveQuest!]!
    bossBattleResult(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): BossBattleResult
    bossBattleResults(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: BossBattleResult_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: BossBattleResult_filter
    ): [BossBattleResult!]!
    component(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Component
    componentFieldValue(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ComponentFieldValue
    componentFieldValues(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ComponentFieldValue_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ComponentFieldValue_filter
    ): [ComponentFieldValue!]!
    componentSchemaField(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ComponentSchemaField
    componentSchemaFields(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ComponentSchemaField_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ComponentSchemaField_filter
    ): [ComponentSchemaField!]!
    components(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Component_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Component_filter
    ): [Component!]!
    contract(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Contract
    contracts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Contract_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Contract_filter
    ): [Contract!]!
    countData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): CountData
    countDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: CountData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: CountData_filter
    ): [CountData!]!
    currencies(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Currency_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Currency_filter
    ): [Currency!]!
    currency(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Currency
    currencyBalance(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): CurrencyBalance
    currencyBalances(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: CurrencyBalance_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: CurrencyBalance_filter
    ): [CurrencyBalance!]!
    dungeonEnemies(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DungeonEnemy_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DungeonEnemy_filter
    ): [DungeonEnemy!]!
    dungeonEnemy(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DungeonEnemy
    dungeonMap(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DungeonMap
    dungeonMaps(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DungeonMap_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DungeonMap_filter
    ): [DungeonMap!]!
    dungeonNode(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DungeonNode
    dungeonNodes(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DungeonNode_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DungeonNode_filter
    ): [DungeonNode!]!
    dungeonTrigger(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DungeonTrigger
    dungeonTriggers(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DungeonTrigger_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DungeonTrigger_filter
    ): [DungeonTrigger!]!
    event(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Event
    events(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Event_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Event_filter
    ): [Event!]!
    gameGlobal(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GameGlobal
    gameGlobals(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: GameGlobal_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: GameGlobal_filter
    ): [GameGlobal!]!
    gameItem(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GameItem
    gameItemBalance(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GameItemBalance
    gameItemBalances(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: GameItemBalance_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: GameItemBalance_filter
    ): [GameItemBalance!]!
    gameItems(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: GameItem_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: GameItem_filter
    ): [GameItem!]!
    holdingMilestone(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HoldingMilestone
    holdingMilestones(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HoldingMilestone_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HoldingMilestone_filter
    ): [HoldingMilestone!]!
    loot(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Loot
    lootSet(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): LootSet
    lootSets(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: LootSet_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: LootSet_filter
    ): [LootSet!]!
    lootTable(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): LootTable
    lootTables(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: LootTable_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: LootTable_filter
    ): [LootTable!]!
    loots(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Loot_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Loot_filter
    ): [Loot!]!
    nft(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NFT
    nftclaimedMilestone(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NFTClaimedMilestone
    nftclaimedMilestones(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: NFTClaimedMilestone_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: NFTClaimedMilestone_filter
    ): [NFTClaimedMilestone!]!
    nfts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: NFT_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: NFT_filter
    ): [NFT!]!
    operatorAccount(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OperatorAccount
    operatorAccounts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OperatorAccount_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OperatorAccount_filter
    ): [OperatorAccount!]!
    pirateStatsData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PirateStatsData
    pirateStatsDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: PirateStatsData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: PirateStatsData_filter
    ): [PirateStatsData!]!
    quest(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Quest
    questInput(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): QuestInput
    questInputs(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: QuestInput_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: QuestInput_filter
    ): [QuestInput!]!
    quests(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Quest_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Quest_filter
    ): [Quest!]!
    recipeDefinition(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RecipeDefinition
    recipeDefinitions(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RecipeDefinition_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RecipeDefinition_filter
    ): [RecipeDefinition!]!
    recipeInput(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RecipeInput
    recipeInputs(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RecipeInput_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RecipeInput_filter
    ): [RecipeInput!]!
    system(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): System
    systems(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: System_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: System_filter
    ): [System!]!
    tokenAction(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenAction
    tokenActionContract(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenActionContract
    tokenActionContracts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenActionContract_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenActionContract_filter
    ): [TokenActionContract!]!
    tokenActions(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenAction_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenAction_filter
    ): [TokenAction!]!
    tokenAttribute(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenAttribute
    tokenAttributes(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenAttribute_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenAttribute_filter
    ): [TokenAttribute!]!
    tokenPointer(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenPointer
    tokenPointers(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenPointer_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenPointer_filter
    ): [TokenPointer!]!
    tokenTemplate(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenTemplate
    tokenTemplates(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenTemplate_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenTemplate_filter
    ): [TokenTemplate!]!
    traitCheck(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TraitCheck
    traitChecks(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TraitCheck_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TraitCheck_filter
    ): [TraitCheck!]!
    traitMetadata(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TraitMetadata_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TraitMetadata_filter
    ): [TraitMetadata!]!
    traitValue(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TraitValue
    traitValues(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TraitValue_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TraitValue_filter
    ): [TraitValue!]!
    worldEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: WorldEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: WorldEntity_filter
    ): [WorldEntity!]!
    worldEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): WorldEntity
    worldEntityComponentValue(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): WorldEntityComponentValue
    worldEntityComponentValues(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: WorldEntityComponentValue_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: WorldEntityComponentValue_filter
    ): [WorldEntityComponentValue!]!
}

type Quest {
    baseSuccessProbability: BigInt!
    cooldownSeconds: BigInt!
    enabled: Boolean!
    id: ID!
    inputs(first: Int = 100, orderBy: QuestInput_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: QuestInput_filter): [QuestInput!]!
    loots(first: Int = 100, orderBy: Loot_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Loot_filter): [Loot!]!
    maxCompletions: BigInt!
    sortIndex: BigInt!
    successXp: BigInt!
    totalCompleted: Int!
    totalFailed: Int!
    totalStarted: Int!
    totalSucceeded: Int!
}

type QuestInput {
    consumable: Boolean!
    energyRequired: BigInt!
    failureBurnProbability: BigInt!
    id: ID!
    required: Boolean!
    successBurnProbability: BigInt!
    tokenPointer: TokenPointer!
    traitChecks(first: Int = 100, orderBy: TraitCheck_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TraitCheck_filter): [TraitCheck!]!
    xpEarnedPercent: BigInt!
}

type RecipeDefinition {
    baseSuccessProbability: BigInt!
    cooldownSeconds: BigInt!
    enabled: Boolean!
    id: ID!
    inputs(first: Int = 100, orderBy: RecipeInput_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: RecipeInput_filter): [RecipeInput!]!
    loots(first: Int = 100, orderBy: Loot_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: Loot_filter): [Loot!]!
    maxCompletions: BigInt!
    sortIndex: BigInt!
    successXp: BigInt!
    totalCompleted: BigInt!
    totalFailed: BigInt!
    totalStarted: BigInt!
    totalSucceeded: BigInt!
}

type RecipeInput {
    consumable: Boolean!
    failureBurnProbability: BigInt!
    id: ID!
    required: Boolean!
    successBurnProbability: BigInt!
    tokenPointer: TokenPointer!
    traitChecks(first: Int = 100, orderBy: TraitCheck_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TraitCheck_filter): [TraitCheck!]!
    xpEarnedPercent: BigInt!
}

type Subscription {
    "Access to subgraph metadata"
    _meta(block: Block_height): _Meta_
    account(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Account
    accountQuestData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AccountQuestData
    accountQuestDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AccountQuestData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AccountQuestData_filter
    ): [AccountQuestData!]!
    accountRecipeData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): AccountRecipeData
    accountRecipeDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: AccountRecipeData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: AccountRecipeData_filter
    ): [AccountRecipeData!]!
    accounts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Account_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Account_filter
    ): [Account!]!
    activeQuest(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ActiveQuest
    activeQuests(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ActiveQuest_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ActiveQuest_filter
    ): [ActiveQuest!]!
    bossBattleResult(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): BossBattleResult
    bossBattleResults(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: BossBattleResult_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: BossBattleResult_filter
    ): [BossBattleResult!]!
    component(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Component
    componentFieldValue(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ComponentFieldValue
    componentFieldValues(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ComponentFieldValue_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ComponentFieldValue_filter
    ): [ComponentFieldValue!]!
    componentSchemaField(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): ComponentSchemaField
    componentSchemaFields(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: ComponentSchemaField_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: ComponentSchemaField_filter
    ): [ComponentSchemaField!]!
    components(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Component_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Component_filter
    ): [Component!]!
    contract(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Contract
    contracts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Contract_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Contract_filter
    ): [Contract!]!
    countData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): CountData
    countDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: CountData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: CountData_filter
    ): [CountData!]!
    currencies(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Currency_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Currency_filter
    ): [Currency!]!
    currency(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Currency
    currencyBalance(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): CurrencyBalance
    currencyBalances(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: CurrencyBalance_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: CurrencyBalance_filter
    ): [CurrencyBalance!]!
    dungeonEnemies(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DungeonEnemy_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DungeonEnemy_filter
    ): [DungeonEnemy!]!
    dungeonEnemy(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DungeonEnemy
    dungeonMap(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DungeonMap
    dungeonMaps(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DungeonMap_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DungeonMap_filter
    ): [DungeonMap!]!
    dungeonNode(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DungeonNode
    dungeonNodes(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DungeonNode_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DungeonNode_filter
    ): [DungeonNode!]!
    dungeonTrigger(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): DungeonTrigger
    dungeonTriggers(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: DungeonTrigger_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: DungeonTrigger_filter
    ): [DungeonTrigger!]!
    event(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Event
    events(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Event_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Event_filter
    ): [Event!]!
    gameGlobal(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GameGlobal
    gameGlobals(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: GameGlobal_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: GameGlobal_filter
    ): [GameGlobal!]!
    gameItem(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GameItem
    gameItemBalance(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): GameItemBalance
    gameItemBalances(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: GameItemBalance_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: GameItemBalance_filter
    ): [GameItemBalance!]!
    gameItems(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: GameItem_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: GameItem_filter
    ): [GameItem!]!
    holdingMilestone(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): HoldingMilestone
    holdingMilestones(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: HoldingMilestone_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: HoldingMilestone_filter
    ): [HoldingMilestone!]!
    loot(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Loot
    lootSet(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): LootSet
    lootSets(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: LootSet_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: LootSet_filter
    ): [LootSet!]!
    lootTable(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): LootTable
    lootTables(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: LootTable_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: LootTable_filter
    ): [LootTable!]!
    loots(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Loot_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Loot_filter
    ): [Loot!]!
    nft(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NFT
    nftclaimedMilestone(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): NFTClaimedMilestone
    nftclaimedMilestones(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: NFTClaimedMilestone_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: NFTClaimedMilestone_filter
    ): [NFTClaimedMilestone!]!
    nfts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: NFT_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: NFT_filter
    ): [NFT!]!
    operatorAccount(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): OperatorAccount
    operatorAccounts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: OperatorAccount_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: OperatorAccount_filter
    ): [OperatorAccount!]!
    pirateStatsData(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): PirateStatsData
    pirateStatsDatas(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: PirateStatsData_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: PirateStatsData_filter
    ): [PirateStatsData!]!
    quest(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): Quest
    questInput(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): QuestInput
    questInputs(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: QuestInput_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: QuestInput_filter
    ): [QuestInput!]!
    quests(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: Quest_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: Quest_filter
    ): [Quest!]!
    recipeDefinition(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RecipeDefinition
    recipeDefinitions(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RecipeDefinition_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RecipeDefinition_filter
    ): [RecipeDefinition!]!
    recipeInput(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): RecipeInput
    recipeInputs(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: RecipeInput_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: RecipeInput_filter
    ): [RecipeInput!]!
    system(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): System
    systems(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: System_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: System_filter
    ): [System!]!
    tokenAction(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenAction
    tokenActionContract(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenActionContract
    tokenActionContracts(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenActionContract_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenActionContract_filter
    ): [TokenActionContract!]!
    tokenActions(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenAction_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenAction_filter
    ): [TokenAction!]!
    tokenAttribute(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenAttribute
    tokenAttributes(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenAttribute_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenAttribute_filter
    ): [TokenAttribute!]!
    tokenPointer(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenPointer
    tokenPointers(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenPointer_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenPointer_filter
    ): [TokenPointer!]!
    tokenTemplate(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TokenTemplate
    tokenTemplates(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TokenTemplate_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TokenTemplate_filter
    ): [TokenTemplate!]!
    traitCheck(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TraitCheck
    traitChecks(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TraitCheck_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TraitCheck_filter
    ): [TraitCheck!]!
    traitMetadata(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TraitMetadata_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TraitMetadata_filter
    ): [TraitMetadata!]!
    traitValue(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): TraitValue
    traitValues(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: TraitValue_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: TraitValue_filter
    ): [TraitValue!]!
    worldEntities(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: WorldEntity_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: WorldEntity_filter
    ): [WorldEntity!]!
    worldEntity(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): WorldEntity
    worldEntityComponentValue(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        id: ID!,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny
    ): WorldEntityComponentValue
    worldEntityComponentValues(
        "The block at which the query should be executed. Can either be a `{ hash: Bytes }` value containing a block hash, a `{ number: Int }` containing the block number, or a `{ number_gte: Int }` containing the minimum block number. In the case of `number_gte`, the query will be executed on the latest block only if the subgraph has progressed to or past the minimum block number. Defaults to the latest block when omitted."
        block: Block_height,
        first: Int = 100,
        orderBy: WorldEntityComponentValue_orderBy,
        orderDirection: OrderDirection,
        skip: Int = 0,
        "Set to `allow` to receive data even if the subgraph has skipped over errors while syncing."
        subgraphError: _SubgraphErrorPolicy_! = deny,
        where: WorldEntityComponentValue_filter
    ): [WorldEntityComponentValue!]!
}

type System {
    contract: Contract
    id: ID!
    worldEntity: WorldEntity
}

type TokenAction {
    actionId: String!
    consumable: Boolean!
    cooldownSeconds: BigInt!
    enabled: Boolean!
    gameItem: GameItem
    id: ID!
    name: String!
    nft: NFT
}

type TokenActionContract {
    contractAddress: String!
    id: ID!
    name: String!
}

type TokenAttribute {
    gameItem: GameItem
    id: ID!
    name: String!
    nft: NFT
    tokenTemplate: TokenTemplate
    value: String!
}

type TokenPointer {
    amount: BigInt!
    id: ID!
    tokenContract: Contract
    tokenId: BigInt!
    tokenType: String!
}

type TokenTemplate {
    animationUrl: String
    attributes(first: Int = 100, orderBy: TokenAttribute_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TokenAttribute_filter): [TokenAttribute!]
    contractAddress: String!
    description: String
    externalUrl: String
    id: ID!
    iframeUrl: String
    imageUrl: String
    modelGltfUrl: String
    name: String
    tags: String
    tokenId: BigInt!
    traits(first: Int = 100, orderBy: TraitValue_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TraitValue_filter): [TraitValue!]
    worldEntity: WorldEntity
}

type TraitCheck {
    checkType: String!
    id: ID!
    traitId: BigInt!
    traitMetadata: TraitMetadata
    traitValue: BigInt!
}

type TraitMetadata {
    behavior: TraitBehavior!
    hidden: Boolean!
    id: ID!
    name: String!
    type: TraitDataType!
}

type TraitValue {
    gameItem: GameItem
    id: ID!
    metadata: TraitMetadata
    nft: NFT
    tokenContract: Contract!
    tokenId: BigInt!
    tokenTemplate: TokenTemplate
    traitId: BigInt!
    value: String
    worldEntity: WorldEntity
}

type WorldEntity {
    account: Account
    component: Component
    components(first: Int = 100, orderBy: WorldEntityComponentValue_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: WorldEntityComponentValue_filter): [WorldEntityComponentValue!]
    contract: Contract
    gameItem: GameItem
    id: ID!
    name: String
    nft: NFT
    owner: Account
    system: System
    tokenTemplate: TokenTemplate
    traits(first: Int = 100, orderBy: TraitValue_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: TraitValue_filter): [TraitValue!]
}

type WorldEntityComponentValue {
    bytesValue: String
    component: Component!
    fields(first: Int = 100, orderBy: ComponentFieldValue_orderBy, orderDirection: OrderDirection, skip: Int = 0, where: ComponentFieldValue_filter): [ComponentFieldValue!]!
    id: ID!
    worldEntity: WorldEntity!
}

type _Block_ {
    "The hash of the block"
    hash: Bytes
    "The block number"
    number: Int!
    "Integer representation of the timestamp stored in blocks for the chain"
    timestamp: Int
}

"The type for the top-level _meta field"
type _Meta_ {
    """

    Information about a specific subgraph block. The hash of the block
    will be null if the _meta field has a block constraint that asks for
    a block number. It will be filled if the _meta field has no block constraint
    and therefore asks for the latest  block
    """
    block: _Block_!
    "The deployment ID"
    deployment: String!
    "If `true`, the subgraph encountered indexing errors at some past block"
    hasIndexingErrors: Boolean!
}

enum AccountQuestData_orderBy {
    account
    account__address
    account__createdAt
    account__id
    completed
    failed
    id
    lastCompletionTime
    quest
    quest__baseSuccessProbability
    quest__cooldownSeconds
    quest__enabled
    quest__id
    quest__maxCompletions
    quest__sortIndex
    quest__successXp
    quest__totalCompleted
    quest__totalFailed
    quest__totalStarted
    quest__totalSucceeded
    started
    succeeded
}

enum AccountRecipeData_orderBy {
    account
    account__address
    account__createdAt
    account__id
    completed
    failed
    id
    lastCompletionTime
    quest
    quest__baseSuccessProbability
    quest__cooldownSeconds
    quest__enabled
    quest__id
    quest__maxCompletions
    quest__sortIndex
    quest__successXp
    quest__totalCompleted
    quest__totalFailed
    quest__totalStarted
    quest__totalSucceeded
    started
    succeeded
}

enum Account_orderBy {
    address
    createdAt
    currencies
    events
    gameItems
    id
    nfts
    operatorAccounts
    questData
    questData__completed
    questData__failed
    questData__id
    questData__lastCompletionTime
    questData__started
    questData__succeeded
    recipeData
    recipeData__completed
    recipeData__failed
    recipeData__id
    recipeData__lastCompletionTime
    recipeData__started
    recipeData__succeeded
    worldEntity
    worldEntity__id
    worldEntity__name
}

enum ActiveQuest_orderBy {
    id
    nft
    nft__animationUrl
    nft__contractAddress
    nft__description
    nft__externalUrl
    nft__id
    nft__iframeUrl
    nft__imagePng1024
    nft__imagePng2048
    nft__imagePng256
    nft__imagePng512
    nft__imageSvg
    nft__imageUrl
    nft__lastEarnTimestamp
    nft__lastEnergyAmount
    nft__lastEnergyEarnable
    nft__lastEnergySpendTimestamp
    nft__lastTransfer
    nft__locked
    nft__minted
    nft__modelGltfUrl
    nft__name
    nft__nftType
    nft__tags
    nft__tokenId
    nfts
    quest
    quest__baseSuccessProbability
    quest__cooldownSeconds
    quest__enabled
    quest__id
    quest__maxCompletions
    quest__sortIndex
    quest__successXp
    quest__totalCompleted
    quest__totalFailed
    quest__totalStarted
    quest__totalSucceeded
}

enum BossBattleResult_orderBy {
    account
    account__address
    account__createdAt
    account__id
    bossEntity
    bossTokenTemplate
    bossTokenTemplate__animationUrl
    bossTokenTemplate__contractAddress
    bossTokenTemplate__description
    bossTokenTemplate__externalUrl
    bossTokenTemplate__id
    bossTokenTemplate__iframeUrl
    bossTokenTemplate__imageUrl
    bossTokenTemplate__modelGltfUrl
    bossTokenTemplate__name
    bossTokenTemplate__tags
    bossTokenTemplate__tokenId
    createdAt
    damageDealt
    damageTaken
    id
    isFinalBlow
    shipEntity
    shipNft
    shipNft__animationUrl
    shipNft__contractAddress
    shipNft__description
    shipNft__externalUrl
    shipNft__id
    shipNft__iframeUrl
    shipNft__imagePng1024
    shipNft__imagePng2048
    shipNft__imagePng256
    shipNft__imagePng512
    shipNft__imageSvg
    shipNft__imageUrl
    shipNft__lastEarnTimestamp
    shipNft__lastEnergyAmount
    shipNft__lastEnergyEarnable
    shipNft__lastEnergySpendTimestamp
    shipNft__lastTransfer
    shipNft__locked
    shipNft__minted
    shipNft__modelGltfUrl
    shipNft__name
    shipNft__nftType
    shipNft__tags
    shipNft__tokenId
}

enum ComponentFieldValue_orderBy {
    componentValue
    componentValue__bytesValue
    componentValue__id
    fieldIndex
    id
    name
    value
    worldEntity
    worldEntity__id
    worldEntity__name
}

enum ComponentSchemaField_orderBy {
    fieldIndex
    id
    name
    type
}

enum Component_orderBy {
    contract
    contract__address
    contract__createdAt
    contract__createdBlock
    contract__id
    contract__name
    contract__paused
    contract__symbol
    contract__type
    contract__uri
    entities
    id
    name
    schema
    worldEntity
    worldEntity__id
    worldEntity__name
}

enum ContractType {
    ERC1155
    ERC20
    ERC721
}

enum Contract_orderBy {
    address
    createdAt
    createdBlock
    holdingMilestones
    id
    name
    owner
    owner__address
    owner__createdAt
    owner__id
    paused
    symbol
    type
    uri
    worldEntity
    worldEntity__id
    worldEntity__name
}

enum CountData_orderBy {
    entityAddress
    entityToken
    id
    key
    packedEntity
    value
}

enum CurrencyBalance_orderBy {
    amount
    currency
    currency__decimals
    currency__id
    currency__name
    currency__symbol
    currency__totalBurned
    currency__totalMinted
    currency__totalSupply
    id
    owner
    owner__address
    owner__createdAt
    owner__id
    totalBurned
    totalMinted
}

enum Currency_orderBy {
    balances
    contract
    contract__address
    contract__createdAt
    contract__createdBlock
    contract__id
    contract__name
    contract__paused
    contract__symbol
    contract__type
    contract__uri
    decimals
    id
    name
    symbol
    totalBurned
    totalMinted
    totalSupply
}

enum DungeonEnemy_orderBy {
    contractAddress
    createdAt
    id
    node
    node__createdAt
    node__id
    tokenId
    tokenTemplate
    tokenTemplate__animationUrl
    tokenTemplate__contractAddress
    tokenTemplate__description
    tokenTemplate__externalUrl
    tokenTemplate__id
    tokenTemplate__iframeUrl
    tokenTemplate__imageUrl
    tokenTemplate__modelGltfUrl
    tokenTemplate__name
    tokenTemplate__tags
    tokenTemplate__tokenId
}

enum DungeonMap_orderBy {
    contractAddress
    createdAt
    id
    nodes
    tokenId
    triggers
}

enum DungeonNode_orderBy {
    createdAt
    enemies
    id
    loots
    map
    map__contractAddress
    map__createdAt
    map__id
    map__tokenId
}

enum DungeonTrigger_orderBy {
    contractAddress
    createdAt
    endAt
    id
    map
    map__contractAddress
    map__createdAt
    map__id
    map__tokenId
    startAt
    tokenId
    tokenTemplate
    tokenTemplate__animationUrl
    tokenTemplate__contractAddress
    tokenTemplate__description
    tokenTemplate__externalUrl
    tokenTemplate__id
    tokenTemplate__iframeUrl
    tokenTemplate__imageUrl
    tokenTemplate__modelGltfUrl
    tokenTemplate__name
    tokenTemplate__tags
    tokenTemplate__tokenId
}

enum EventType {
    PLAYER
    SYSTEM
    UNDEFINED
}

enum Event_orderBy {
    account
    account__address
    account__createdAt
    account__id
    amount
    contractAddress
    createdAt
    currency
    currency__decimals
    currency__id
    currency__name
    currency__symbol
    currency__totalBurned
    currency__totalMinted
    currency__totalSupply
    from
    from__address
    from__createdAt
    from__id
    gameItem
    gameItem__animationUrl
    gameItem__burned
    gameItem__contractAddress
    gameItem__currentSupply
    gameItem__description
    gameItem__externalUrl
    gameItem__id
    gameItem__iframeUrl
    gameItem__imageUrl
    gameItem__maxSupply
    gameItem__minted
    gameItem__modelGltfUrl
    gameItem__name
    gameItem__numOwners
    gameItem__recyclable
    gameItem__tags
    gameItem__tokenId
    id
    name
    nft
    nft__animationUrl
    nft__contractAddress
    nft__description
    nft__externalUrl
    nft__id
    nft__iframeUrl
    nft__imagePng1024
    nft__imagePng2048
    nft__imagePng256
    nft__imagePng512
    nft__imageSvg
    nft__imageUrl
    nft__lastEarnTimestamp
    nft__lastEnergyAmount
    nft__lastEnergyEarnable
    nft__lastEnergySpendTimestamp
    nft__lastTransfer
    nft__locked
    nft__minted
    nft__modelGltfUrl
    nft__name
    nft__nftType
    nft__tags
    nft__tokenId
    quest
    quest__baseSuccessProbability
    quest__cooldownSeconds
    quest__enabled
    quest__id
    quest__maxCompletions
    quest__sortIndex
    quest__successXp
    quest__totalCompleted
    quest__totalFailed
    quest__totalStarted
    quest__totalSucceeded
    recipeDefinition
    recipeDefinition__baseSuccessProbability
    recipeDefinition__cooldownSeconds
    recipeDefinition__enabled
    recipeDefinition__id
    recipeDefinition__maxCompletions
    recipeDefinition__sortIndex
    recipeDefinition__successXp
    recipeDefinition__totalCompleted
    recipeDefinition__totalFailed
    recipeDefinition__totalStarted
    recipeDefinition__totalSucceeded
    relevantAccounts
    to
    to__address
    to__createdAt
    to__id
    tokenId
    transactionHash
    type
    value
    worldEntity
    worldEntity__id
    worldEntity__name
}

enum GameGlobalDataType {
    BOOL
    INT256
    INT256_ARRAY
    NOT_INITIALIZED
    STRING
    STRING_ARRAY
    UINT256
    UINT256_ARRAY
}

enum GameGlobal_orderBy {
    dataType
    id
    name
    value
}

enum GameItemBalance_orderBy {
    amount
    gameItem
    gameItem__animationUrl
    gameItem__burned
    gameItem__contractAddress
    gameItem__currentSupply
    gameItem__description
    gameItem__externalUrl
    gameItem__id
    gameItem__iframeUrl
    gameItem__imageUrl
    gameItem__maxSupply
    gameItem__minted
    gameItem__modelGltfUrl
    gameItem__name
    gameItem__numOwners
    gameItem__recyclable
    gameItem__tags
    gameItem__tokenId
    id
    lockedAmount
    owner
    owner__address
    owner__createdAt
    owner__id
}

enum GameItem_orderBy {
    actions
    animationUrl
    attributes
    burned
    contractAddress
    currentSupply
    description
    events
    externalUrl
    id
    iframeUrl
    imageUrl
    maxSupply
    minted
    modelGltfUrl
    name
    numOwners
    recyclable
    tags
    tokenId
    tokenTemplate
    tokenTemplate__animationUrl
    tokenTemplate__contractAddress
    tokenTemplate__description
    tokenTemplate__externalUrl
    tokenTemplate__id
    tokenTemplate__iframeUrl
    tokenTemplate__imageUrl
    tokenTemplate__modelGltfUrl
    tokenTemplate__name
    tokenTemplate__tags
    tokenTemplate__tokenId
    traits
    worldEntity
    worldEntity__id
    worldEntity__name
}

enum HoldingMilestone_orderBy {
    id
    loots
    milestoneIndex
    timeHeldSeconds
    tokenContract
    tokenContract__address
    tokenContract__createdAt
    tokenContract__createdBlock
    tokenContract__id
    tokenContract__name
    tokenContract__paused
    tokenContract__symbol
    tokenContract__type
    tokenContract__uri
}

enum LootSet_orderBy {
    id
    loots
}

enum LootTable_orderBy {
    id
    lootSets
    maxSupply
    mints
    weights
}

enum Loot_orderBy {
    amount
    id
    lootId
    lootType
    tokenContract
    tokenContract__address
    tokenContract__createdAt
    tokenContract__createdBlock
    tokenContract__id
    tokenContract__name
    tokenContract__paused
    tokenContract__symbol
    tokenContract__type
    tokenContract__uri
}

enum NFTClaimedMilestone_orderBy {
    claimed
    claimedAt
    holdingMilestone
    holdingMilestone__id
    holdingMilestone__milestoneIndex
    holdingMilestone__timeHeldSeconds
    id
    milestoneIndex
    nft
    nft__animationUrl
    nft__contractAddress
    nft__description
    nft__externalUrl
    nft__id
    nft__iframeUrl
    nft__imagePng1024
    nft__imagePng2048
    nft__imagePng256
    nft__imagePng512
    nft__imageSvg
    nft__imageUrl
    nft__lastEarnTimestamp
    nft__lastEnergyAmount
    nft__lastEnergyEarnable
    nft__lastEnergySpendTimestamp
    nft__lastTransfer
    nft__locked
    nft__minted
    nft__modelGltfUrl
    nft__name
    nft__nftType
    nft__tags
    nft__tokenId
}

enum NFT_orderBy {
    actions
    animationUrl
    attributes
    claimedMilestones
    contractAddress
    description
    events
    externalUrl
    id
    iframeUrl
    imagePng1024
    imagePng2048
    imagePng256
    imagePng512
    imageSvg
    imageUrl
    lastEarnTimestamp
    lastEnergyAmount
    lastEnergyEarnable
    lastEnergySpendTimestamp
    lastTransfer
    locked
    minted
    modelGltfUrl
    name
    nftType
    owner
    owner__address
    owner__createdAt
    owner__id
    tags
    tokenId
    tokenTemplate
    tokenTemplate__animationUrl
    tokenTemplate__contractAddress
    tokenTemplate__description
    tokenTemplate__externalUrl
    tokenTemplate__id
    tokenTemplate__iframeUrl
    tokenTemplate__imageUrl
    tokenTemplate__modelGltfUrl
    tokenTemplate__name
    tokenTemplate__tags
    tokenTemplate__tokenId
    traits
    worldEntity
    worldEntity__id
    worldEntity__name
}

enum OperatorAccount_orderBy {
    address
    expiration
    id
    playerAccount
    playerAccount__address
    playerAccount__createdAt
    playerAccount__id
}

"Defines the order direction, either ascending or descending"
enum OrderDirection {
    asc
    desc
}

enum PirateStatsData_orderBy {
    energyGained
    energySpent
    goldMinted
    id
    intervalStartAt
    intervalType
    nft
    nft__animationUrl
    nft__contractAddress
    nft__description
    nft__externalUrl
    nft__id
    nft__iframeUrl
    nft__imagePng1024
    nft__imagePng2048
    nft__imagePng256
    nft__imagePng512
    nft__imageSvg
    nft__imageUrl
    nft__lastEarnTimestamp
    nft__lastEnergyAmount
    nft__lastEnergyEarnable
    nft__lastEnergySpendTimestamp
    nft__lastTransfer
    nft__locked
    nft__minted
    nft__modelGltfUrl
    nft__name
    nft__nftType
    nft__tags
    nft__tokenId
    questsCompleted
    questsFailed
    questsStarted
    questsSucceeded
}

enum QuestInput_orderBy {
    consumable
    energyRequired
    failureBurnProbability
    id
    required
    successBurnProbability
    tokenPointer
    tokenPointer__amount
    tokenPointer__id
    tokenPointer__tokenId
    tokenPointer__tokenType
    traitChecks
    xpEarnedPercent
}

enum Quest_orderBy {
    baseSuccessProbability
    cooldownSeconds
    enabled
    id
    inputs
    loots
    maxCompletions
    sortIndex
    successXp
    totalCompleted
    totalFailed
    totalStarted
    totalSucceeded
}

enum RecipeDefinition_orderBy {
    baseSuccessProbability
    cooldownSeconds
    enabled
    id
    inputs
    loots
    maxCompletions
    sortIndex
    successXp
    totalCompleted
    totalFailed
    totalStarted
    totalSucceeded
}

enum RecipeInput_orderBy {
    consumable
    failureBurnProbability
    id
    required
    successBurnProbability
    tokenPointer
    tokenPointer__amount
    tokenPointer__id
    tokenPointer__tokenId
    tokenPointer__tokenType
    traitChecks
    xpEarnedPercent
}

enum StatsIntervalType {
    ALLTIME
    BIWEEKLY
    DAILY
    MONTHLY
    WEEKLY
}

enum System_orderBy {
    contract
    contract__address
    contract__createdAt
    contract__createdBlock
    contract__id
    contract__name
    contract__paused
    contract__symbol
    contract__type
    contract__uri
    id
    worldEntity
    worldEntity__id
    worldEntity__name
}

enum TokenActionContract_orderBy {
    contractAddress
    id
    name
}

enum TokenAction_orderBy {
    actionId
    consumable
    cooldownSeconds
    enabled
    gameItem
    gameItem__animationUrl
    gameItem__burned
    gameItem__contractAddress
    gameItem__currentSupply
    gameItem__description
    gameItem__externalUrl
    gameItem__id
    gameItem__iframeUrl
    gameItem__imageUrl
    gameItem__maxSupply
    gameItem__minted
    gameItem__modelGltfUrl
    gameItem__name
    gameItem__numOwners
    gameItem__recyclable
    gameItem__tags
    gameItem__tokenId
    id
    name
    nft
    nft__animationUrl
    nft__contractAddress
    nft__description
    nft__externalUrl
    nft__id
    nft__iframeUrl
    nft__imagePng1024
    nft__imagePng2048
    nft__imagePng256
    nft__imagePng512
    nft__imageSvg
    nft__imageUrl
    nft__lastEarnTimestamp
    nft__lastEnergyAmount
    nft__lastEnergyEarnable
    nft__lastEnergySpendTimestamp
    nft__lastTransfer
    nft__locked
    nft__minted
    nft__modelGltfUrl
    nft__name
    nft__nftType
    nft__tags
    nft__tokenId
}

enum TokenAttribute_orderBy {
    gameItem
    gameItem__animationUrl
    gameItem__burned
    gameItem__contractAddress
    gameItem__currentSupply
    gameItem__description
    gameItem__externalUrl
    gameItem__id
    gameItem__iframeUrl
    gameItem__imageUrl
    gameItem__maxSupply
    gameItem__minted
    gameItem__modelGltfUrl
    gameItem__name
    gameItem__numOwners
    gameItem__recyclable
    gameItem__tags
    gameItem__tokenId
    id
    name
    nft
    nft__animationUrl
    nft__contractAddress
    nft__description
    nft__externalUrl
    nft__id
    nft__iframeUrl
    nft__imagePng1024
    nft__imagePng2048
    nft__imagePng256
    nft__imagePng512
    nft__imageSvg
    nft__imageUrl
    nft__lastEarnTimestamp
    nft__lastEnergyAmount
    nft__lastEnergyEarnable
    nft__lastEnergySpendTimestamp
    nft__lastTransfer
    nft__locked
    nft__minted
    nft__modelGltfUrl
    nft__name
    nft__nftType
    nft__tags
    nft__tokenId
    tokenTemplate
    tokenTemplate__animationUrl
    tokenTemplate__contractAddress
    tokenTemplate__description
    tokenTemplate__externalUrl
    tokenTemplate__id
    tokenTemplate__iframeUrl
    tokenTemplate__imageUrl
    tokenTemplate__modelGltfUrl
    tokenTemplate__name
    tokenTemplate__tags
    tokenTemplate__tokenId
    value
}

enum TokenPointer_orderBy {
    amount
    id
    tokenContract
    tokenContract__address
    tokenContract__createdAt
    tokenContract__createdBlock
    tokenContract__id
    tokenContract__name
    tokenContract__paused
    tokenContract__symbol
    tokenContract__type
    tokenContract__uri
    tokenId
    tokenType
}

enum TokenTemplate_orderBy {
    animationUrl
    attributes
    contractAddress
    description
    externalUrl
    id
    iframeUrl
    imageUrl
    modelGltfUrl
    name
    tags
    tokenId
    traits
    worldEntity
    worldEntity__id
    worldEntity__name
}

enum TraitBehavior {
    DECREMENT_ONLY
    IMMUTABLE
    INCREMENT_ONLY
    NOT_INITIALIZED
    UNRESTRICTED
}

enum TraitCheck_orderBy {
    checkType
    id
    traitId
    traitMetadata
    traitMetadata__behavior
    traitMetadata__hidden
    traitMetadata__id
    traitMetadata__name
    traitMetadata__type
    traitValue
}

enum TraitDataType {
    BOOL
    INT
    INT_ARRAY
    NOT_INITIALIZED
    STRING
    UINT
    UINT_ARRAY
}

enum TraitMetadata_orderBy {
    behavior
    hidden
    id
    name
    type
}

enum TraitValue_orderBy {
    gameItem
    gameItem__animationUrl
    gameItem__burned
    gameItem__contractAddress
    gameItem__currentSupply
    gameItem__description
    gameItem__externalUrl
    gameItem__id
    gameItem__iframeUrl
    gameItem__imageUrl
    gameItem__maxSupply
    gameItem__minted
    gameItem__modelGltfUrl
    gameItem__name
    gameItem__numOwners
    gameItem__recyclable
    gameItem__tags
    gameItem__tokenId
    id
    metadata
    metadata__behavior
    metadata__hidden
    metadata__id
    metadata__name
    metadata__type
    nft
    nft__animationUrl
    nft__contractAddress
    nft__description
    nft__externalUrl
    nft__id
    nft__iframeUrl
    nft__imagePng1024
    nft__imagePng2048
    nft__imagePng256
    nft__imagePng512
    nft__imageSvg
    nft__imageUrl
    nft__lastEarnTimestamp
    nft__lastEnergyAmount
    nft__lastEnergyEarnable
    nft__lastEnergySpendTimestamp
    nft__lastTransfer
    nft__locked
    nft__minted
    nft__modelGltfUrl
    nft__name
    nft__nftType
    nft__tags
    nft__tokenId
    tokenContract
    tokenContract__address
    tokenContract__createdAt
    tokenContract__createdBlock
    tokenContract__id
    tokenContract__name
    tokenContract__paused
    tokenContract__symbol
    tokenContract__type
    tokenContract__uri
    tokenId
    tokenTemplate
    tokenTemplate__animationUrl
    tokenTemplate__contractAddress
    tokenTemplate__description
    tokenTemplate__externalUrl
    tokenTemplate__id
    tokenTemplate__iframeUrl
    tokenTemplate__imageUrl
    tokenTemplate__modelGltfUrl
    tokenTemplate__name
    tokenTemplate__tags
    tokenTemplate__tokenId
    traitId
    value
    worldEntity
    worldEntity__id
    worldEntity__name
}

enum WorldEntityComponentValue_orderBy {
    bytesValue
    component
    component__id
    component__name
    fields
    id
    worldEntity
    worldEntity__id
    worldEntity__name
}

enum WorldEntity_orderBy {
    account
    account__address
    account__createdAt
    account__id
    component
    component__id
    component__name
    components
    contract
    contract__address
    contract__createdAt
    contract__createdBlock
    contract__id
    contract__name
    contract__paused
    contract__symbol
    contract__type
    contract__uri
    gameItem
    gameItem__animationUrl
    gameItem__burned
    gameItem__contractAddress
    gameItem__currentSupply
    gameItem__description
    gameItem__externalUrl
    gameItem__id
    gameItem__iframeUrl
    gameItem__imageUrl
    gameItem__maxSupply
    gameItem__minted
    gameItem__modelGltfUrl
    gameItem__name
    gameItem__numOwners
    gameItem__recyclable
    gameItem__tags
    gameItem__tokenId
    id
    name
    nft
    nft__animationUrl
    nft__contractAddress
    nft__description
    nft__externalUrl
    nft__id
    nft__iframeUrl
    nft__imagePng1024
    nft__imagePng2048
    nft__imagePng256
    nft__imagePng512
    nft__imageSvg
    nft__imageUrl
    nft__lastEarnTimestamp
    nft__lastEnergyAmount
    nft__lastEnergyEarnable
    nft__lastEnergySpendTimestamp
    nft__lastTransfer
    nft__locked
    nft__minted
    nft__modelGltfUrl
    nft__name
    nft__nftType
    nft__tags
    nft__tokenId
    owner
    owner__address
    owner__createdAt
    owner__id
    system
    system__id
    tokenTemplate
    tokenTemplate__animationUrl
    tokenTemplate__contractAddress
    tokenTemplate__description
    tokenTemplate__externalUrl
    tokenTemplate__id
    tokenTemplate__iframeUrl
    tokenTemplate__imageUrl
    tokenTemplate__modelGltfUrl
    tokenTemplate__name
    tokenTemplate__tags
    tokenTemplate__tokenId
    traits
}

enum _SubgraphErrorPolicy_ {
    "Data will be returned even if the subgraph has indexing errors"
    allow
    "If the subgraph has indexing errors, data will be omitted. The default."
    deny
}

scalar BigDecimal

scalar BigInt

scalar Bytes

"""

8 bytes signed integer
"""
scalar Int8

input AccountQuestData_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    account: String
    account_: Account_filter
    account_contains: String
    account_contains_nocase: String
    account_ends_with: String
    account_ends_with_nocase: String
    account_gt: String
    account_gte: String
    account_in: [String!]
    account_lt: String
    account_lte: String
    account_not: String
    account_not_contains: String
    account_not_contains_nocase: String
    account_not_ends_with: String
    account_not_ends_with_nocase: String
    account_not_in: [String!]
    account_not_starts_with: String
    account_not_starts_with_nocase: String
    account_starts_with: String
    account_starts_with_nocase: String
    and: [AccountQuestData_filter]
    completed: Int
    completed_gt: Int
    completed_gte: Int
    completed_in: [Int!]
    completed_lt: Int
    completed_lte: Int
    completed_not: Int
    completed_not_in: [Int!]
    failed: Int
    failed_gt: Int
    failed_gte: Int
    failed_in: [Int!]
    failed_lt: Int
    failed_lte: Int
    failed_not: Int
    failed_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    lastCompletionTime: BigInt
    lastCompletionTime_gt: BigInt
    lastCompletionTime_gte: BigInt
    lastCompletionTime_in: [BigInt!]
    lastCompletionTime_lt: BigInt
    lastCompletionTime_lte: BigInt
    lastCompletionTime_not: BigInt
    lastCompletionTime_not_in: [BigInt!]
    or: [AccountQuestData_filter]
    quest: String
    quest_: Quest_filter
    quest_contains: String
    quest_contains_nocase: String
    quest_ends_with: String
    quest_ends_with_nocase: String
    quest_gt: String
    quest_gte: String
    quest_in: [String!]
    quest_lt: String
    quest_lte: String
    quest_not: String
    quest_not_contains: String
    quest_not_contains_nocase: String
    quest_not_ends_with: String
    quest_not_ends_with_nocase: String
    quest_not_in: [String!]
    quest_not_starts_with: String
    quest_not_starts_with_nocase: String
    quest_starts_with: String
    quest_starts_with_nocase: String
    started: Int
    started_gt: Int
    started_gte: Int
    started_in: [Int!]
    started_lt: Int
    started_lte: Int
    started_not: Int
    started_not_in: [Int!]
    succeeded: Int
    succeeded_gt: Int
    succeeded_gte: Int
    succeeded_in: [Int!]
    succeeded_lt: Int
    succeeded_lte: Int
    succeeded_not: Int
    succeeded_not_in: [Int!]
}

input AccountRecipeData_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    account: String
    account_: Account_filter
    account_contains: String
    account_contains_nocase: String
    account_ends_with: String
    account_ends_with_nocase: String
    account_gt: String
    account_gte: String
    account_in: [String!]
    account_lt: String
    account_lte: String
    account_not: String
    account_not_contains: String
    account_not_contains_nocase: String
    account_not_ends_with: String
    account_not_ends_with_nocase: String
    account_not_in: [String!]
    account_not_starts_with: String
    account_not_starts_with_nocase: String
    account_starts_with: String
    account_starts_with_nocase: String
    and: [AccountRecipeData_filter]
    completed: Int
    completed_gt: Int
    completed_gte: Int
    completed_in: [Int!]
    completed_lt: Int
    completed_lte: Int
    completed_not: Int
    completed_not_in: [Int!]
    failed: Int
    failed_gt: Int
    failed_gte: Int
    failed_in: [Int!]
    failed_lt: Int
    failed_lte: Int
    failed_not: Int
    failed_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    lastCompletionTime: BigInt
    lastCompletionTime_gt: BigInt
    lastCompletionTime_gte: BigInt
    lastCompletionTime_in: [BigInt!]
    lastCompletionTime_lt: BigInt
    lastCompletionTime_lte: BigInt
    lastCompletionTime_not: BigInt
    lastCompletionTime_not_in: [BigInt!]
    or: [AccountRecipeData_filter]
    quest: String
    quest_: Quest_filter
    quest_contains: String
    quest_contains_nocase: String
    quest_ends_with: String
    quest_ends_with_nocase: String
    quest_gt: String
    quest_gte: String
    quest_in: [String!]
    quest_lt: String
    quest_lte: String
    quest_not: String
    quest_not_contains: String
    quest_not_contains_nocase: String
    quest_not_ends_with: String
    quest_not_ends_with_nocase: String
    quest_not_in: [String!]
    quest_not_starts_with: String
    quest_not_starts_with_nocase: String
    quest_starts_with: String
    quest_starts_with_nocase: String
    started: Int
    started_gt: Int
    started_gte: Int
    started_in: [Int!]
    started_lt: Int
    started_lte: Int
    started_not: Int
    started_not_in: [Int!]
    succeeded: Int
    succeeded_gt: Int
    succeeded_gte: Int
    succeeded_in: [Int!]
    succeeded_lt: Int
    succeeded_lte: Int
    succeeded_not: Int
    succeeded_not_in: [Int!]
}

input Account_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    address: String
    address_contains: String
    address_contains_nocase: String
    address_ends_with: String
    address_ends_with_nocase: String
    address_gt: String
    address_gte: String
    address_in: [String!]
    address_lt: String
    address_lte: String
    address_not: String
    address_not_contains: String
    address_not_contains_nocase: String
    address_not_ends_with: String
    address_not_ends_with_nocase: String
    address_not_in: [String!]
    address_not_starts_with: String
    address_not_starts_with_nocase: String
    address_starts_with: String
    address_starts_with_nocase: String
    and: [Account_filter]
    createdAt: BigInt
    createdAt_gt: BigInt
    createdAt_gte: BigInt
    createdAt_in: [BigInt!]
    createdAt_lt: BigInt
    createdAt_lte: BigInt
    createdAt_not: BigInt
    createdAt_not_in: [BigInt!]
    currencies_: CurrencyBalance_filter
    events_: Event_filter
    gameItems_: GameItemBalance_filter
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    nfts_: NFT_filter
    operatorAccounts_: OperatorAccount_filter
    or: [Account_filter]
    questData_: AccountQuestData_filter
    recipeData_: AccountRecipeData_filter
    worldEntity: String
    worldEntity_: WorldEntity_filter
    worldEntity_contains: String
    worldEntity_contains_nocase: String
    worldEntity_ends_with: String
    worldEntity_ends_with_nocase: String
    worldEntity_gt: String
    worldEntity_gte: String
    worldEntity_in: [String!]
    worldEntity_lt: String
    worldEntity_lte: String
    worldEntity_not: String
    worldEntity_not_contains: String
    worldEntity_not_contains_nocase: String
    worldEntity_not_ends_with: String
    worldEntity_not_ends_with_nocase: String
    worldEntity_not_in: [String!]
    worldEntity_not_starts_with: String
    worldEntity_not_starts_with_nocase: String
    worldEntity_starts_with: String
    worldEntity_starts_with_nocase: String
}

input ActiveQuest_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [ActiveQuest_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    nft: String
    nft_: NFT_filter
    nft_contains: String
    nft_contains_nocase: String
    nft_ends_with: String
    nft_ends_with_nocase: String
    nft_gt: String
    nft_gte: String
    nft_in: [String!]
    nft_lt: String
    nft_lte: String
    nft_not: String
    nft_not_contains: String
    nft_not_contains_nocase: String
    nft_not_ends_with: String
    nft_not_ends_with_nocase: String
    nft_not_in: [String!]
    nft_not_starts_with: String
    nft_not_starts_with_nocase: String
    nft_starts_with: String
    nft_starts_with_nocase: String
    nfts: [String!]
    nfts_: NFT_filter
    nfts_contains: [String!]
    nfts_contains_nocase: [String!]
    nfts_not: [String!]
    nfts_not_contains: [String!]
    nfts_not_contains_nocase: [String!]
    or: [ActiveQuest_filter]
    quest: String
    quest_: Quest_filter
    quest_contains: String
    quest_contains_nocase: String
    quest_ends_with: String
    quest_ends_with_nocase: String
    quest_gt: String
    quest_gte: String
    quest_in: [String!]
    quest_lt: String
    quest_lte: String
    quest_not: String
    quest_not_contains: String
    quest_not_contains_nocase: String
    quest_not_ends_with: String
    quest_not_ends_with_nocase: String
    quest_not_in: [String!]
    quest_not_starts_with: String
    quest_not_starts_with_nocase: String
    quest_starts_with: String
    quest_starts_with_nocase: String
}

input BlockChangedFilter {
    number_gte: Int!
}

input Block_height {
    hash: Bytes
    number: Int
    number_gte: Int
}

input BossBattleResult_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    account: String
    account_: Account_filter
    account_contains: String
    account_contains_nocase: String
    account_ends_with: String
    account_ends_with_nocase: String
    account_gt: String
    account_gte: String
    account_in: [String!]
    account_lt: String
    account_lte: String
    account_not: String
    account_not_contains: String
    account_not_contains_nocase: String
    account_not_ends_with: String
    account_not_ends_with_nocase: String
    account_not_in: [String!]
    account_not_starts_with: String
    account_not_starts_with_nocase: String
    account_starts_with: String
    account_starts_with_nocase: String
    and: [BossBattleResult_filter]
    bossEntity: BigInt
    bossEntity_gt: BigInt
    bossEntity_gte: BigInt
    bossEntity_in: [BigInt!]
    bossEntity_lt: BigInt
    bossEntity_lte: BigInt
    bossEntity_not: BigInt
    bossEntity_not_in: [BigInt!]
    bossTokenTemplate: String
    bossTokenTemplate_: TokenTemplate_filter
    bossTokenTemplate_contains: String
    bossTokenTemplate_contains_nocase: String
    bossTokenTemplate_ends_with: String
    bossTokenTemplate_ends_with_nocase: String
    bossTokenTemplate_gt: String
    bossTokenTemplate_gte: String
    bossTokenTemplate_in: [String!]
    bossTokenTemplate_lt: String
    bossTokenTemplate_lte: String
    bossTokenTemplate_not: String
    bossTokenTemplate_not_contains: String
    bossTokenTemplate_not_contains_nocase: String
    bossTokenTemplate_not_ends_with: String
    bossTokenTemplate_not_ends_with_nocase: String
    bossTokenTemplate_not_in: [String!]
    bossTokenTemplate_not_starts_with: String
    bossTokenTemplate_not_starts_with_nocase: String
    bossTokenTemplate_starts_with: String
    bossTokenTemplate_starts_with_nocase: String
    createdAt: BigInt
    createdAt_gt: BigInt
    createdAt_gte: BigInt
    createdAt_in: [BigInt!]
    createdAt_lt: BigInt
    createdAt_lte: BigInt
    createdAt_not: BigInt
    createdAt_not_in: [BigInt!]
    damageDealt: BigInt
    damageDealt_gt: BigInt
    damageDealt_gte: BigInt
    damageDealt_in: [BigInt!]
    damageDealt_lt: BigInt
    damageDealt_lte: BigInt
    damageDealt_not: BigInt
    damageDealt_not_in: [BigInt!]
    damageTaken: BigInt
    damageTaken_gt: BigInt
    damageTaken_gte: BigInt
    damageTaken_in: [BigInt!]
    damageTaken_lt: BigInt
    damageTaken_lte: BigInt
    damageTaken_not: BigInt
    damageTaken_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    isFinalBlow: Boolean
    isFinalBlow_in: [Boolean!]
    isFinalBlow_not: Boolean
    isFinalBlow_not_in: [Boolean!]
    or: [BossBattleResult_filter]
    shipEntity: BigInt
    shipEntity_gt: BigInt
    shipEntity_gte: BigInt
    shipEntity_in: [BigInt!]
    shipEntity_lt: BigInt
    shipEntity_lte: BigInt
    shipEntity_not: BigInt
    shipEntity_not_in: [BigInt!]
    shipNft: String
    shipNft_: NFT_filter
    shipNft_contains: String
    shipNft_contains_nocase: String
    shipNft_ends_with: String
    shipNft_ends_with_nocase: String
    shipNft_gt: String
    shipNft_gte: String
    shipNft_in: [String!]
    shipNft_lt: String
    shipNft_lte: String
    shipNft_not: String
    shipNft_not_contains: String
    shipNft_not_contains_nocase: String
    shipNft_not_ends_with: String
    shipNft_not_ends_with_nocase: String
    shipNft_not_in: [String!]
    shipNft_not_starts_with: String
    shipNft_not_starts_with_nocase: String
    shipNft_starts_with: String
    shipNft_starts_with_nocase: String
}

input ComponentFieldValue_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [ComponentFieldValue_filter]
    componentValue: String
    componentValue_: WorldEntityComponentValue_filter
    componentValue_contains: String
    componentValue_contains_nocase: String
    componentValue_ends_with: String
    componentValue_ends_with_nocase: String
    componentValue_gt: String
    componentValue_gte: String
    componentValue_in: [String!]
    componentValue_lt: String
    componentValue_lte: String
    componentValue_not: String
    componentValue_not_contains: String
    componentValue_not_contains_nocase: String
    componentValue_not_ends_with: String
    componentValue_not_ends_with_nocase: String
    componentValue_not_in: [String!]
    componentValue_not_starts_with: String
    componentValue_not_starts_with_nocase: String
    componentValue_starts_with: String
    componentValue_starts_with_nocase: String
    fieldIndex: Int
    fieldIndex_gt: Int
    fieldIndex_gte: Int
    fieldIndex_in: [Int!]
    fieldIndex_lt: Int
    fieldIndex_lte: Int
    fieldIndex_not: Int
    fieldIndex_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    or: [ComponentFieldValue_filter]
    value: String
    value_contains: String
    value_contains_nocase: String
    value_ends_with: String
    value_ends_with_nocase: String
    value_gt: String
    value_gte: String
    value_in: [String!]
    value_lt: String
    value_lte: String
    value_not: String
    value_not_contains: String
    value_not_contains_nocase: String
    value_not_ends_with: String
    value_not_ends_with_nocase: String
    value_not_in: [String!]
    value_not_starts_with: String
    value_not_starts_with_nocase: String
    value_starts_with: String
    value_starts_with_nocase: String
    worldEntity: String
    worldEntity_: WorldEntity_filter
    worldEntity_contains: String
    worldEntity_contains_nocase: String
    worldEntity_ends_with: String
    worldEntity_ends_with_nocase: String
    worldEntity_gt: String
    worldEntity_gte: String
    worldEntity_in: [String!]
    worldEntity_lt: String
    worldEntity_lte: String
    worldEntity_not: String
    worldEntity_not_contains: String
    worldEntity_not_contains_nocase: String
    worldEntity_not_ends_with: String
    worldEntity_not_ends_with_nocase: String
    worldEntity_not_in: [String!]
    worldEntity_not_starts_with: String
    worldEntity_not_starts_with_nocase: String
    worldEntity_starts_with: String
    worldEntity_starts_with_nocase: String
}

input ComponentSchemaField_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [ComponentSchemaField_filter]
    fieldIndex: Int
    fieldIndex_gt: Int
    fieldIndex_gte: Int
    fieldIndex_in: [Int!]
    fieldIndex_lt: Int
    fieldIndex_lte: Int
    fieldIndex_not: Int
    fieldIndex_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    or: [ComponentSchemaField_filter]
    type: Int
    type_gt: Int
    type_gte: Int
    type_in: [Int!]
    type_lt: Int
    type_lte: Int
    type_not: Int
    type_not_in: [Int!]
}

input Component_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [Component_filter]
    contract: String
    contract_: Contract_filter
    contract_contains: String
    contract_contains_nocase: String
    contract_ends_with: String
    contract_ends_with_nocase: String
    contract_gt: String
    contract_gte: String
    contract_in: [String!]
    contract_lt: String
    contract_lte: String
    contract_not: String
    contract_not_contains: String
    contract_not_contains_nocase: String
    contract_not_ends_with: String
    contract_not_ends_with_nocase: String
    contract_not_in: [String!]
    contract_not_starts_with: String
    contract_not_starts_with_nocase: String
    contract_starts_with: String
    contract_starts_with_nocase: String
    entities_: WorldEntityComponentValue_filter
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    or: [Component_filter]
    schema: [String!]
    schema_: ComponentSchemaField_filter
    schema_contains: [String!]
    schema_contains_nocase: [String!]
    schema_not: [String!]
    schema_not_contains: [String!]
    schema_not_contains_nocase: [String!]
    worldEntity: String
    worldEntity_: WorldEntity_filter
    worldEntity_contains: String
    worldEntity_contains_nocase: String
    worldEntity_ends_with: String
    worldEntity_ends_with_nocase: String
    worldEntity_gt: String
    worldEntity_gte: String
    worldEntity_in: [String!]
    worldEntity_lt: String
    worldEntity_lte: String
    worldEntity_not: String
    worldEntity_not_contains: String
    worldEntity_not_contains_nocase: String
    worldEntity_not_ends_with: String
    worldEntity_not_ends_with_nocase: String
    worldEntity_not_in: [String!]
    worldEntity_not_starts_with: String
    worldEntity_not_starts_with_nocase: String
    worldEntity_starts_with: String
    worldEntity_starts_with_nocase: String
}

input Contract_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    address: String
    address_contains: String
    address_contains_nocase: String
    address_ends_with: String
    address_ends_with_nocase: String
    address_gt: String
    address_gte: String
    address_in: [String!]
    address_lt: String
    address_lte: String
    address_not: String
    address_not_contains: String
    address_not_contains_nocase: String
    address_not_ends_with: String
    address_not_ends_with_nocase: String
    address_not_in: [String!]
    address_not_starts_with: String
    address_not_starts_with_nocase: String
    address_starts_with: String
    address_starts_with_nocase: String
    and: [Contract_filter]
    createdAt: BigInt
    createdAt_gt: BigInt
    createdAt_gte: BigInt
    createdAt_in: [BigInt!]
    createdAt_lt: BigInt
    createdAt_lte: BigInt
    createdAt_not: BigInt
    createdAt_not_in: [BigInt!]
    createdBlock: BigInt
    createdBlock_gt: BigInt
    createdBlock_gte: BigInt
    createdBlock_in: [BigInt!]
    createdBlock_lt: BigInt
    createdBlock_lte: BigInt
    createdBlock_not: BigInt
    createdBlock_not_in: [BigInt!]
    holdingMilestones_: HoldingMilestone_filter
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    or: [Contract_filter]
    owner: String
    owner_: Account_filter
    owner_contains: String
    owner_contains_nocase: String
    owner_ends_with: String
    owner_ends_with_nocase: String
    owner_gt: String
    owner_gte: String
    owner_in: [String!]
    owner_lt: String
    owner_lte: String
    owner_not: String
    owner_not_contains: String
    owner_not_contains_nocase: String
    owner_not_ends_with: String
    owner_not_ends_with_nocase: String
    owner_not_in: [String!]
    owner_not_starts_with: String
    owner_not_starts_with_nocase: String
    owner_starts_with: String
    owner_starts_with_nocase: String
    paused: Boolean
    paused_in: [Boolean!]
    paused_not: Boolean
    paused_not_in: [Boolean!]
    symbol: String
    symbol_contains: String
    symbol_contains_nocase: String
    symbol_ends_with: String
    symbol_ends_with_nocase: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_contains_nocase: String
    symbol_not_ends_with: String
    symbol_not_ends_with_nocase: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_not_starts_with_nocase: String
    symbol_starts_with: String
    symbol_starts_with_nocase: String
    type: ContractType
    type_in: [ContractType!]
    type_not: ContractType
    type_not_in: [ContractType!]
    uri: String
    uri_contains: String
    uri_contains_nocase: String
    uri_ends_with: String
    uri_ends_with_nocase: String
    uri_gt: String
    uri_gte: String
    uri_in: [String!]
    uri_lt: String
    uri_lte: String
    uri_not: String
    uri_not_contains: String
    uri_not_contains_nocase: String
    uri_not_ends_with: String
    uri_not_ends_with_nocase: String
    uri_not_in: [String!]
    uri_not_starts_with: String
    uri_not_starts_with_nocase: String
    uri_starts_with: String
    uri_starts_with_nocase: String
    worldEntity: String
    worldEntity_: WorldEntity_filter
    worldEntity_contains: String
    worldEntity_contains_nocase: String
    worldEntity_ends_with: String
    worldEntity_ends_with_nocase: String
    worldEntity_gt: String
    worldEntity_gte: String
    worldEntity_in: [String!]
    worldEntity_lt: String
    worldEntity_lte: String
    worldEntity_not: String
    worldEntity_not_contains: String
    worldEntity_not_contains_nocase: String
    worldEntity_not_ends_with: String
    worldEntity_not_ends_with_nocase: String
    worldEntity_not_in: [String!]
    worldEntity_not_starts_with: String
    worldEntity_not_starts_with_nocase: String
    worldEntity_starts_with: String
    worldEntity_starts_with_nocase: String
}

input CountData_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [CountData_filter]
    entityAddress: String
    entityAddress_contains: String
    entityAddress_contains_nocase: String
    entityAddress_ends_with: String
    entityAddress_ends_with_nocase: String
    entityAddress_gt: String
    entityAddress_gte: String
    entityAddress_in: [String!]
    entityAddress_lt: String
    entityAddress_lte: String
    entityAddress_not: String
    entityAddress_not_contains: String
    entityAddress_not_contains_nocase: String
    entityAddress_not_ends_with: String
    entityAddress_not_ends_with_nocase: String
    entityAddress_not_in: [String!]
    entityAddress_not_starts_with: String
    entityAddress_not_starts_with_nocase: String
    entityAddress_starts_with: String
    entityAddress_starts_with_nocase: String
    entityToken: BigInt
    entityToken_gt: BigInt
    entityToken_gte: BigInt
    entityToken_in: [BigInt!]
    entityToken_lt: BigInt
    entityToken_lte: BigInt
    entityToken_not: BigInt
    entityToken_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    key: BigInt
    key_gt: BigInt
    key_gte: BigInt
    key_in: [BigInt!]
    key_lt: BigInt
    key_lte: BigInt
    key_not: BigInt
    key_not_in: [BigInt!]
    or: [CountData_filter]
    packedEntity: BigInt
    packedEntity_gt: BigInt
    packedEntity_gte: BigInt
    packedEntity_in: [BigInt!]
    packedEntity_lt: BigInt
    packedEntity_lte: BigInt
    packedEntity_not: BigInt
    packedEntity_not_in: [BigInt!]
    value: BigInt
    value_gt: BigInt
    value_gte: BigInt
    value_in: [BigInt!]
    value_lt: BigInt
    value_lte: BigInt
    value_not: BigInt
    value_not_in: [BigInt!]
}

input CurrencyBalance_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    and: [CurrencyBalance_filter]
    currency: String
    currency_: Currency_filter
    currency_contains: String
    currency_contains_nocase: String
    currency_ends_with: String
    currency_ends_with_nocase: String
    currency_gt: String
    currency_gte: String
    currency_in: [String!]
    currency_lt: String
    currency_lte: String
    currency_not: String
    currency_not_contains: String
    currency_not_contains_nocase: String
    currency_not_ends_with: String
    currency_not_ends_with_nocase: String
    currency_not_in: [String!]
    currency_not_starts_with: String
    currency_not_starts_with_nocase: String
    currency_starts_with: String
    currency_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [CurrencyBalance_filter]
    owner: String
    owner_: Account_filter
    owner_contains: String
    owner_contains_nocase: String
    owner_ends_with: String
    owner_ends_with_nocase: String
    owner_gt: String
    owner_gte: String
    owner_in: [String!]
    owner_lt: String
    owner_lte: String
    owner_not: String
    owner_not_contains: String
    owner_not_contains_nocase: String
    owner_not_ends_with: String
    owner_not_ends_with_nocase: String
    owner_not_in: [String!]
    owner_not_starts_with: String
    owner_not_starts_with_nocase: String
    owner_starts_with: String
    owner_starts_with_nocase: String
    totalBurned: BigInt
    totalBurned_gt: BigInt
    totalBurned_gte: BigInt
    totalBurned_in: [BigInt!]
    totalBurned_lt: BigInt
    totalBurned_lte: BigInt
    totalBurned_not: BigInt
    totalBurned_not_in: [BigInt!]
    totalMinted: BigInt
    totalMinted_gt: BigInt
    totalMinted_gte: BigInt
    totalMinted_in: [BigInt!]
    totalMinted_lt: BigInt
    totalMinted_lte: BigInt
    totalMinted_not: BigInt
    totalMinted_not_in: [BigInt!]
}

input Currency_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [Currency_filter]
    balances_: CurrencyBalance_filter
    contract: String
    contract_: Contract_filter
    contract_contains: String
    contract_contains_nocase: String
    contract_ends_with: String
    contract_ends_with_nocase: String
    contract_gt: String
    contract_gte: String
    contract_in: [String!]
    contract_lt: String
    contract_lte: String
    contract_not: String
    contract_not_contains: String
    contract_not_contains_nocase: String
    contract_not_ends_with: String
    contract_not_ends_with_nocase: String
    contract_not_in: [String!]
    contract_not_starts_with: String
    contract_not_starts_with_nocase: String
    contract_starts_with: String
    contract_starts_with_nocase: String
    decimals: Int
    decimals_gt: Int
    decimals_gte: Int
    decimals_in: [Int!]
    decimals_lt: Int
    decimals_lte: Int
    decimals_not: Int
    decimals_not_in: [Int!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    or: [Currency_filter]
    symbol: String
    symbol_contains: String
    symbol_contains_nocase: String
    symbol_ends_with: String
    symbol_ends_with_nocase: String
    symbol_gt: String
    symbol_gte: String
    symbol_in: [String!]
    symbol_lt: String
    symbol_lte: String
    symbol_not: String
    symbol_not_contains: String
    symbol_not_contains_nocase: String
    symbol_not_ends_with: String
    symbol_not_ends_with_nocase: String
    symbol_not_in: [String!]
    symbol_not_starts_with: String
    symbol_not_starts_with_nocase: String
    symbol_starts_with: String
    symbol_starts_with_nocase: String
    totalBurned: BigInt
    totalBurned_gt: BigInt
    totalBurned_gte: BigInt
    totalBurned_in: [BigInt!]
    totalBurned_lt: BigInt
    totalBurned_lte: BigInt
    totalBurned_not: BigInt
    totalBurned_not_in: [BigInt!]
    totalMinted: BigInt
    totalMinted_gt: BigInt
    totalMinted_gte: BigInt
    totalMinted_in: [BigInt!]
    totalMinted_lt: BigInt
    totalMinted_lte: BigInt
    totalMinted_not: BigInt
    totalMinted_not_in: [BigInt!]
    totalSupply: BigInt
    totalSupply_gt: BigInt
    totalSupply_gte: BigInt
    totalSupply_in: [BigInt!]
    totalSupply_lt: BigInt
    totalSupply_lte: BigInt
    totalSupply_not: BigInt
    totalSupply_not_in: [BigInt!]
}

input DungeonEnemy_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [DungeonEnemy_filter]
    contractAddress: String
    contractAddress_contains: String
    contractAddress_contains_nocase: String
    contractAddress_ends_with: String
    contractAddress_ends_with_nocase: String
    contractAddress_gt: String
    contractAddress_gte: String
    contractAddress_in: [String!]
    contractAddress_lt: String
    contractAddress_lte: String
    contractAddress_not: String
    contractAddress_not_contains: String
    contractAddress_not_contains_nocase: String
    contractAddress_not_ends_with: String
    contractAddress_not_ends_with_nocase: String
    contractAddress_not_in: [String!]
    contractAddress_not_starts_with: String
    contractAddress_not_starts_with_nocase: String
    contractAddress_starts_with: String
    contractAddress_starts_with_nocase: String
    createdAt: BigInt
    createdAt_gt: BigInt
    createdAt_gte: BigInt
    createdAt_in: [BigInt!]
    createdAt_lt: BigInt
    createdAt_lte: BigInt
    createdAt_not: BigInt
    createdAt_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    node: String
    node_: DungeonNode_filter
    node_contains: String
    node_contains_nocase: String
    node_ends_with: String
    node_ends_with_nocase: String
    node_gt: String
    node_gte: String
    node_in: [String!]
    node_lt: String
    node_lte: String
    node_not: String
    node_not_contains: String
    node_not_contains_nocase: String
    node_not_ends_with: String
    node_not_ends_with_nocase: String
    node_not_in: [String!]
    node_not_starts_with: String
    node_not_starts_with_nocase: String
    node_starts_with: String
    node_starts_with_nocase: String
    or: [DungeonEnemy_filter]
    tokenId: BigInt
    tokenId_gt: BigInt
    tokenId_gte: BigInt
    tokenId_in: [BigInt!]
    tokenId_lt: BigInt
    tokenId_lte: BigInt
    tokenId_not: BigInt
    tokenId_not_in: [BigInt!]
    tokenTemplate: String
    tokenTemplate_: TokenTemplate_filter
    tokenTemplate_contains: String
    tokenTemplate_contains_nocase: String
    tokenTemplate_ends_with: String
    tokenTemplate_ends_with_nocase: String
    tokenTemplate_gt: String
    tokenTemplate_gte: String
    tokenTemplate_in: [String!]
    tokenTemplate_lt: String
    tokenTemplate_lte: String
    tokenTemplate_not: String
    tokenTemplate_not_contains: String
    tokenTemplate_not_contains_nocase: String
    tokenTemplate_not_ends_with: String
    tokenTemplate_not_ends_with_nocase: String
    tokenTemplate_not_in: [String!]
    tokenTemplate_not_starts_with: String
    tokenTemplate_not_starts_with_nocase: String
    tokenTemplate_starts_with: String
    tokenTemplate_starts_with_nocase: String
}

input DungeonMap_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [DungeonMap_filter]
    contractAddress: String
    contractAddress_contains: String
    contractAddress_contains_nocase: String
    contractAddress_ends_with: String
    contractAddress_ends_with_nocase: String
    contractAddress_gt: String
    contractAddress_gte: String
    contractAddress_in: [String!]
    contractAddress_lt: String
    contractAddress_lte: String
    contractAddress_not: String
    contractAddress_not_contains: String
    contractAddress_not_contains_nocase: String
    contractAddress_not_ends_with: String
    contractAddress_not_ends_with_nocase: String
    contractAddress_not_in: [String!]
    contractAddress_not_starts_with: String
    contractAddress_not_starts_with_nocase: String
    contractAddress_starts_with: String
    contractAddress_starts_with_nocase: String
    createdAt: BigInt
    createdAt_gt: BigInt
    createdAt_gte: BigInt
    createdAt_in: [BigInt!]
    createdAt_lt: BigInt
    createdAt_lte: BigInt
    createdAt_not: BigInt
    createdAt_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    nodes_: DungeonNode_filter
    or: [DungeonMap_filter]
    tokenId: BigInt
    tokenId_gt: BigInt
    tokenId_gte: BigInt
    tokenId_in: [BigInt!]
    tokenId_lt: BigInt
    tokenId_lte: BigInt
    tokenId_not: BigInt
    tokenId_not_in: [BigInt!]
    triggers_: DungeonTrigger_filter
}

input DungeonNode_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [DungeonNode_filter]
    createdAt: BigInt
    createdAt_gt: BigInt
    createdAt_gte: BigInt
    createdAt_in: [BigInt!]
    createdAt_lt: BigInt
    createdAt_lte: BigInt
    createdAt_not: BigInt
    createdAt_not_in: [BigInt!]
    enemies: [String!]
    enemies_: DungeonEnemy_filter
    enemies_contains: [String!]
    enemies_contains_nocase: [String!]
    enemies_not: [String!]
    enemies_not_contains: [String!]
    enemies_not_contains_nocase: [String!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    loots: [String!]
    loots_: Loot_filter
    loots_contains: [String!]
    loots_contains_nocase: [String!]
    loots_not: [String!]
    loots_not_contains: [String!]
    loots_not_contains_nocase: [String!]
    map: String
    map_: DungeonMap_filter
    map_contains: String
    map_contains_nocase: String
    map_ends_with: String
    map_ends_with_nocase: String
    map_gt: String
    map_gte: String
    map_in: [String!]
    map_lt: String
    map_lte: String
    map_not: String
    map_not_contains: String
    map_not_contains_nocase: String
    map_not_ends_with: String
    map_not_ends_with_nocase: String
    map_not_in: [String!]
    map_not_starts_with: String
    map_not_starts_with_nocase: String
    map_starts_with: String
    map_starts_with_nocase: String
    or: [DungeonNode_filter]
}

input DungeonTrigger_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [DungeonTrigger_filter]
    contractAddress: String
    contractAddress_contains: String
    contractAddress_contains_nocase: String
    contractAddress_ends_with: String
    contractAddress_ends_with_nocase: String
    contractAddress_gt: String
    contractAddress_gte: String
    contractAddress_in: [String!]
    contractAddress_lt: String
    contractAddress_lte: String
    contractAddress_not: String
    contractAddress_not_contains: String
    contractAddress_not_contains_nocase: String
    contractAddress_not_ends_with: String
    contractAddress_not_ends_with_nocase: String
    contractAddress_not_in: [String!]
    contractAddress_not_starts_with: String
    contractAddress_not_starts_with_nocase: String
    contractAddress_starts_with: String
    contractAddress_starts_with_nocase: String
    createdAt: BigInt
    createdAt_gt: BigInt
    createdAt_gte: BigInt
    createdAt_in: [BigInt!]
    createdAt_lt: BigInt
    createdAt_lte: BigInt
    createdAt_not: BigInt
    createdAt_not_in: [BigInt!]
    endAt: BigInt
    endAt_gt: BigInt
    endAt_gte: BigInt
    endAt_in: [BigInt!]
    endAt_lt: BigInt
    endAt_lte: BigInt
    endAt_not: BigInt
    endAt_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    map: String
    map_: DungeonMap_filter
    map_contains: String
    map_contains_nocase: String
    map_ends_with: String
    map_ends_with_nocase: String
    map_gt: String
    map_gte: String
    map_in: [String!]
    map_lt: String
    map_lte: String
    map_not: String
    map_not_contains: String
    map_not_contains_nocase: String
    map_not_ends_with: String
    map_not_ends_with_nocase: String
    map_not_in: [String!]
    map_not_starts_with: String
    map_not_starts_with_nocase: String
    map_starts_with: String
    map_starts_with_nocase: String
    or: [DungeonTrigger_filter]
    startAt: BigInt
    startAt_gt: BigInt
    startAt_gte: BigInt
    startAt_in: [BigInt!]
    startAt_lt: BigInt
    startAt_lte: BigInt
    startAt_not: BigInt
    startAt_not_in: [BigInt!]
    tokenId: BigInt
    tokenId_gt: BigInt
    tokenId_gte: BigInt
    tokenId_in: [BigInt!]
    tokenId_lt: BigInt
    tokenId_lte: BigInt
    tokenId_not: BigInt
    tokenId_not_in: [BigInt!]
    tokenTemplate: String
    tokenTemplate_: TokenTemplate_filter
    tokenTemplate_contains: String
    tokenTemplate_contains_nocase: String
    tokenTemplate_ends_with: String
    tokenTemplate_ends_with_nocase: String
    tokenTemplate_gt: String
    tokenTemplate_gte: String
    tokenTemplate_in: [String!]
    tokenTemplate_lt: String
    tokenTemplate_lte: String
    tokenTemplate_not: String
    tokenTemplate_not_contains: String
    tokenTemplate_not_contains_nocase: String
    tokenTemplate_not_ends_with: String
    tokenTemplate_not_ends_with_nocase: String
    tokenTemplate_not_in: [String!]
    tokenTemplate_not_starts_with: String
    tokenTemplate_not_starts_with_nocase: String
    tokenTemplate_starts_with: String
    tokenTemplate_starts_with_nocase: String
}

input Event_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    account: String
    account_: Account_filter
    account_contains: String
    account_contains_nocase: String
    account_ends_with: String
    account_ends_with_nocase: String
    account_gt: String
    account_gte: String
    account_in: [String!]
    account_lt: String
    account_lte: String
    account_not: String
    account_not_contains: String
    account_not_contains_nocase: String
    account_not_ends_with: String
    account_not_ends_with_nocase: String
    account_not_in: [String!]
    account_not_starts_with: String
    account_not_starts_with_nocase: String
    account_starts_with: String
    account_starts_with_nocase: String
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    and: [Event_filter]
    contractAddress: String
    contractAddress_contains: String
    contractAddress_contains_nocase: String
    contractAddress_ends_with: String
    contractAddress_ends_with_nocase: String
    contractAddress_gt: String
    contractAddress_gte: String
    contractAddress_in: [String!]
    contractAddress_lt: String
    contractAddress_lte: String
    contractAddress_not: String
    contractAddress_not_contains: String
    contractAddress_not_contains_nocase: String
    contractAddress_not_ends_with: String
    contractAddress_not_ends_with_nocase: String
    contractAddress_not_in: [String!]
    contractAddress_not_starts_with: String
    contractAddress_not_starts_with_nocase: String
    contractAddress_starts_with: String
    contractAddress_starts_with_nocase: String
    createdAt: BigInt
    createdAt_gt: BigInt
    createdAt_gte: BigInt
    createdAt_in: [BigInt!]
    createdAt_lt: BigInt
    createdAt_lte: BigInt
    createdAt_not: BigInt
    createdAt_not_in: [BigInt!]
    currency: String
    currency_: Currency_filter
    currency_contains: String
    currency_contains_nocase: String
    currency_ends_with: String
    currency_ends_with_nocase: String
    currency_gt: String
    currency_gte: String
    currency_in: [String!]
    currency_lt: String
    currency_lte: String
    currency_not: String
    currency_not_contains: String
    currency_not_contains_nocase: String
    currency_not_ends_with: String
    currency_not_ends_with_nocase: String
    currency_not_in: [String!]
    currency_not_starts_with: String
    currency_not_starts_with_nocase: String
    currency_starts_with: String
    currency_starts_with_nocase: String
    from: String
    from_: Account_filter
    from_contains: String
    from_contains_nocase: String
    from_ends_with: String
    from_ends_with_nocase: String
    from_gt: String
    from_gte: String
    from_in: [String!]
    from_lt: String
    from_lte: String
    from_not: String
    from_not_contains: String
    from_not_contains_nocase: String
    from_not_ends_with: String
    from_not_ends_with_nocase: String
    from_not_in: [String!]
    from_not_starts_with: String
    from_not_starts_with_nocase: String
    from_starts_with: String
    from_starts_with_nocase: String
    gameItem: String
    gameItem_: GameItem_filter
    gameItem_contains: String
    gameItem_contains_nocase: String
    gameItem_ends_with: String
    gameItem_ends_with_nocase: String
    gameItem_gt: String
    gameItem_gte: String
    gameItem_in: [String!]
    gameItem_lt: String
    gameItem_lte: String
    gameItem_not: String
    gameItem_not_contains: String
    gameItem_not_contains_nocase: String
    gameItem_not_ends_with: String
    gameItem_not_ends_with_nocase: String
    gameItem_not_in: [String!]
    gameItem_not_starts_with: String
    gameItem_not_starts_with_nocase: String
    gameItem_starts_with: String
    gameItem_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    nft: String
    nft_: NFT_filter
    nft_contains: String
    nft_contains_nocase: String
    nft_ends_with: String
    nft_ends_with_nocase: String
    nft_gt: String
    nft_gte: String
    nft_in: [String!]
    nft_lt: String
    nft_lte: String
    nft_not: String
    nft_not_contains: String
    nft_not_contains_nocase: String
    nft_not_ends_with: String
    nft_not_ends_with_nocase: String
    nft_not_in: [String!]
    nft_not_starts_with: String
    nft_not_starts_with_nocase: String
    nft_starts_with: String
    nft_starts_with_nocase: String
    or: [Event_filter]
    quest: String
    quest_: Quest_filter
    quest_contains: String
    quest_contains_nocase: String
    quest_ends_with: String
    quest_ends_with_nocase: String
    quest_gt: String
    quest_gte: String
    quest_in: [String!]
    quest_lt: String
    quest_lte: String
    quest_not: String
    quest_not_contains: String
    quest_not_contains_nocase: String
    quest_not_ends_with: String
    quest_not_ends_with_nocase: String
    quest_not_in: [String!]
    quest_not_starts_with: String
    quest_not_starts_with_nocase: String
    quest_starts_with: String
    quest_starts_with_nocase: String
    recipeDefinition: String
    recipeDefinition_: RecipeDefinition_filter
    recipeDefinition_contains: String
    recipeDefinition_contains_nocase: String
    recipeDefinition_ends_with: String
    recipeDefinition_ends_with_nocase: String
    recipeDefinition_gt: String
    recipeDefinition_gte: String
    recipeDefinition_in: [String!]
    recipeDefinition_lt: String
    recipeDefinition_lte: String
    recipeDefinition_not: String
    recipeDefinition_not_contains: String
    recipeDefinition_not_contains_nocase: String
    recipeDefinition_not_ends_with: String
    recipeDefinition_not_ends_with_nocase: String
    recipeDefinition_not_in: [String!]
    recipeDefinition_not_starts_with: String
    recipeDefinition_not_starts_with_nocase: String
    recipeDefinition_starts_with: String
    recipeDefinition_starts_with_nocase: String
    relevantAccounts: [String!]
    relevantAccounts_: Account_filter
    relevantAccounts_contains: [String!]
    relevantAccounts_contains_nocase: [String!]
    relevantAccounts_not: [String!]
    relevantAccounts_not_contains: [String!]
    relevantAccounts_not_contains_nocase: [String!]
    to: String
    to_: Account_filter
    to_contains: String
    to_contains_nocase: String
    to_ends_with: String
    to_ends_with_nocase: String
    to_gt: String
    to_gte: String
    to_in: [String!]
    to_lt: String
    to_lte: String
    to_not: String
    to_not_contains: String
    to_not_contains_nocase: String
    to_not_ends_with: String
    to_not_ends_with_nocase: String
    to_not_in: [String!]
    to_not_starts_with: String
    to_not_starts_with_nocase: String
    to_starts_with: String
    to_starts_with_nocase: String
    tokenId: BigInt
    tokenId_gt: BigInt
    tokenId_gte: BigInt
    tokenId_in: [BigInt!]
    tokenId_lt: BigInt
    tokenId_lte: BigInt
    tokenId_not: BigInt
    tokenId_not_in: [BigInt!]
    transactionHash: String
    transactionHash_contains: String
    transactionHash_contains_nocase: String
    transactionHash_ends_with: String
    transactionHash_ends_with_nocase: String
    transactionHash_gt: String
    transactionHash_gte: String
    transactionHash_in: [String!]
    transactionHash_lt: String
    transactionHash_lte: String
    transactionHash_not: String
    transactionHash_not_contains: String
    transactionHash_not_contains_nocase: String
    transactionHash_not_ends_with: String
    transactionHash_not_ends_with_nocase: String
    transactionHash_not_in: [String!]
    transactionHash_not_starts_with: String
    transactionHash_not_starts_with_nocase: String
    transactionHash_starts_with: String
    transactionHash_starts_with_nocase: String
    type: EventType
    type_in: [EventType!]
    type_not: EventType
    type_not_in: [EventType!]
    value: BigInt
    value_gt: BigInt
    value_gte: BigInt
    value_in: [BigInt!]
    value_lt: BigInt
    value_lte: BigInt
    value_not: BigInt
    value_not_in: [BigInt!]
    worldEntity: String
    worldEntity_: WorldEntity_filter
    worldEntity_contains: String
    worldEntity_contains_nocase: String
    worldEntity_ends_with: String
    worldEntity_ends_with_nocase: String
    worldEntity_gt: String
    worldEntity_gte: String
    worldEntity_in: [String!]
    worldEntity_lt: String
    worldEntity_lte: String
    worldEntity_not: String
    worldEntity_not_contains: String
    worldEntity_not_contains_nocase: String
    worldEntity_not_ends_with: String
    worldEntity_not_ends_with_nocase: String
    worldEntity_not_in: [String!]
    worldEntity_not_starts_with: String
    worldEntity_not_starts_with_nocase: String
    worldEntity_starts_with: String
    worldEntity_starts_with_nocase: String
}

input GameGlobal_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [GameGlobal_filter]
    dataType: GameGlobalDataType
    dataType_in: [GameGlobalDataType!]
    dataType_not: GameGlobalDataType
    dataType_not_in: [GameGlobalDataType!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    or: [GameGlobal_filter]
    value: String
    value_contains: String
    value_contains_nocase: String
    value_ends_with: String
    value_ends_with_nocase: String
    value_gt: String
    value_gte: String
    value_in: [String!]
    value_lt: String
    value_lte: String
    value_not: String
    value_not_contains: String
    value_not_contains_nocase: String
    value_not_ends_with: String
    value_not_ends_with_nocase: String
    value_not_in: [String!]
    value_not_starts_with: String
    value_not_starts_with_nocase: String
    value_starts_with: String
    value_starts_with_nocase: String
}

input GameItemBalance_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    and: [GameItemBalance_filter]
    gameItem: String
    gameItem_: GameItem_filter
    gameItem_contains: String
    gameItem_contains_nocase: String
    gameItem_ends_with: String
    gameItem_ends_with_nocase: String
    gameItem_gt: String
    gameItem_gte: String
    gameItem_in: [String!]
    gameItem_lt: String
    gameItem_lte: String
    gameItem_not: String
    gameItem_not_contains: String
    gameItem_not_contains_nocase: String
    gameItem_not_ends_with: String
    gameItem_not_ends_with_nocase: String
    gameItem_not_in: [String!]
    gameItem_not_starts_with: String
    gameItem_not_starts_with_nocase: String
    gameItem_starts_with: String
    gameItem_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    lockedAmount: BigInt
    lockedAmount_gt: BigInt
    lockedAmount_gte: BigInt
    lockedAmount_in: [BigInt!]
    lockedAmount_lt: BigInt
    lockedAmount_lte: BigInt
    lockedAmount_not: BigInt
    lockedAmount_not_in: [BigInt!]
    or: [GameItemBalance_filter]
    owner: String
    owner_: Account_filter
    owner_contains: String
    owner_contains_nocase: String
    owner_ends_with: String
    owner_ends_with_nocase: String
    owner_gt: String
    owner_gte: String
    owner_in: [String!]
    owner_lt: String
    owner_lte: String
    owner_not: String
    owner_not_contains: String
    owner_not_contains_nocase: String
    owner_not_ends_with: String
    owner_not_ends_with_nocase: String
    owner_not_in: [String!]
    owner_not_starts_with: String
    owner_not_starts_with_nocase: String
    owner_starts_with: String
    owner_starts_with_nocase: String
}

input GameItem_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    actions_: TokenAction_filter
    and: [GameItem_filter]
    animationUrl: String
    animationUrl_contains: String
    animationUrl_contains_nocase: String
    animationUrl_ends_with: String
    animationUrl_ends_with_nocase: String
    animationUrl_gt: String
    animationUrl_gte: String
    animationUrl_in: [String!]
    animationUrl_lt: String
    animationUrl_lte: String
    animationUrl_not: String
    animationUrl_not_contains: String
    animationUrl_not_contains_nocase: String
    animationUrl_not_ends_with: String
    animationUrl_not_ends_with_nocase: String
    animationUrl_not_in: [String!]
    animationUrl_not_starts_with: String
    animationUrl_not_starts_with_nocase: String
    animationUrl_starts_with: String
    animationUrl_starts_with_nocase: String
    attributes_: TokenAttribute_filter
    burned: BigInt
    burned_gt: BigInt
    burned_gte: BigInt
    burned_in: [BigInt!]
    burned_lt: BigInt
    burned_lte: BigInt
    burned_not: BigInt
    burned_not_in: [BigInt!]
    contractAddress: String
    contractAddress_contains: String
    contractAddress_contains_nocase: String
    contractAddress_ends_with: String
    contractAddress_ends_with_nocase: String
    contractAddress_gt: String
    contractAddress_gte: String
    contractAddress_in: [String!]
    contractAddress_lt: String
    contractAddress_lte: String
    contractAddress_not: String
    contractAddress_not_contains: String
    contractAddress_not_contains_nocase: String
    contractAddress_not_ends_with: String
    contractAddress_not_ends_with_nocase: String
    contractAddress_not_in: [String!]
    contractAddress_not_starts_with: String
    contractAddress_not_starts_with_nocase: String
    contractAddress_starts_with: String
    contractAddress_starts_with_nocase: String
    currentSupply: BigInt
    currentSupply_gt: BigInt
    currentSupply_gte: BigInt
    currentSupply_in: [BigInt!]
    currentSupply_lt: BigInt
    currentSupply_lte: BigInt
    currentSupply_not: BigInt
    currentSupply_not_in: [BigInt!]
    description: String
    description_contains: String
    description_contains_nocase: String
    description_ends_with: String
    description_ends_with_nocase: String
    description_gt: String
    description_gte: String
    description_in: [String!]
    description_lt: String
    description_lte: String
    description_not: String
    description_not_contains: String
    description_not_contains_nocase: String
    description_not_ends_with: String
    description_not_ends_with_nocase: String
    description_not_in: [String!]
    description_not_starts_with: String
    description_not_starts_with_nocase: String
    description_starts_with: String
    description_starts_with_nocase: String
    events_: Event_filter
    externalUrl: String
    externalUrl_contains: String
    externalUrl_contains_nocase: String
    externalUrl_ends_with: String
    externalUrl_ends_with_nocase: String
    externalUrl_gt: String
    externalUrl_gte: String
    externalUrl_in: [String!]
    externalUrl_lt: String
    externalUrl_lte: String
    externalUrl_not: String
    externalUrl_not_contains: String
    externalUrl_not_contains_nocase: String
    externalUrl_not_ends_with: String
    externalUrl_not_ends_with_nocase: String
    externalUrl_not_in: [String!]
    externalUrl_not_starts_with: String
    externalUrl_not_starts_with_nocase: String
    externalUrl_starts_with: String
    externalUrl_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    iframeUrl: String
    iframeUrl_contains: String
    iframeUrl_contains_nocase: String
    iframeUrl_ends_with: String
    iframeUrl_ends_with_nocase: String
    iframeUrl_gt: String
    iframeUrl_gte: String
    iframeUrl_in: [String!]
    iframeUrl_lt: String
    iframeUrl_lte: String
    iframeUrl_not: String
    iframeUrl_not_contains: String
    iframeUrl_not_contains_nocase: String
    iframeUrl_not_ends_with: String
    iframeUrl_not_ends_with_nocase: String
    iframeUrl_not_in: [String!]
    iframeUrl_not_starts_with: String
    iframeUrl_not_starts_with_nocase: String
    iframeUrl_starts_with: String
    iframeUrl_starts_with_nocase: String
    imageUrl: String
    imageUrl_contains: String
    imageUrl_contains_nocase: String
    imageUrl_ends_with: String
    imageUrl_ends_with_nocase: String
    imageUrl_gt: String
    imageUrl_gte: String
    imageUrl_in: [String!]
    imageUrl_lt: String
    imageUrl_lte: String
    imageUrl_not: String
    imageUrl_not_contains: String
    imageUrl_not_contains_nocase: String
    imageUrl_not_ends_with: String
    imageUrl_not_ends_with_nocase: String
    imageUrl_not_in: [String!]
    imageUrl_not_starts_with: String
    imageUrl_not_starts_with_nocase: String
    imageUrl_starts_with: String
    imageUrl_starts_with_nocase: String
    maxSupply: BigInt
    maxSupply_gt: BigInt
    maxSupply_gte: BigInt
    maxSupply_in: [BigInt!]
    maxSupply_lt: BigInt
    maxSupply_lte: BigInt
    maxSupply_not: BigInt
    maxSupply_not_in: [BigInt!]
    minted: BigInt
    minted_gt: BigInt
    minted_gte: BigInt
    minted_in: [BigInt!]
    minted_lt: BigInt
    minted_lte: BigInt
    minted_not: BigInt
    minted_not_in: [BigInt!]
    modelGltfUrl: String
    modelGltfUrl_contains: String
    modelGltfUrl_contains_nocase: String
    modelGltfUrl_ends_with: String
    modelGltfUrl_ends_with_nocase: String
    modelGltfUrl_gt: String
    modelGltfUrl_gte: String
    modelGltfUrl_in: [String!]
    modelGltfUrl_lt: String
    modelGltfUrl_lte: String
    modelGltfUrl_not: String
    modelGltfUrl_not_contains: String
    modelGltfUrl_not_contains_nocase: String
    modelGltfUrl_not_ends_with: String
    modelGltfUrl_not_ends_with_nocase: String
    modelGltfUrl_not_in: [String!]
    modelGltfUrl_not_starts_with: String
    modelGltfUrl_not_starts_with_nocase: String
    modelGltfUrl_starts_with: String
    modelGltfUrl_starts_with_nocase: String
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    numOwners: BigInt
    numOwners_gt: BigInt
    numOwners_gte: BigInt
    numOwners_in: [BigInt!]
    numOwners_lt: BigInt
    numOwners_lte: BigInt
    numOwners_not: BigInt
    numOwners_not_in: [BigInt!]
    or: [GameItem_filter]
    recyclable: Boolean
    recyclable_in: [Boolean!]
    recyclable_not: Boolean
    recyclable_not_in: [Boolean!]
    tags: String
    tags_contains: String
    tags_contains_nocase: String
    tags_ends_with: String
    tags_ends_with_nocase: String
    tags_gt: String
    tags_gte: String
    tags_in: [String!]
    tags_lt: String
    tags_lte: String
    tags_not: String
    tags_not_contains: String
    tags_not_contains_nocase: String
    tags_not_ends_with: String
    tags_not_ends_with_nocase: String
    tags_not_in: [String!]
    tags_not_starts_with: String
    tags_not_starts_with_nocase: String
    tags_starts_with: String
    tags_starts_with_nocase: String
    tokenId: BigInt
    tokenId_gt: BigInt
    tokenId_gte: BigInt
    tokenId_in: [BigInt!]
    tokenId_lt: BigInt
    tokenId_lte: BigInt
    tokenId_not: BigInt
    tokenId_not_in: [BigInt!]
    tokenTemplate: String
    tokenTemplate_: TokenTemplate_filter
    tokenTemplate_contains: String
    tokenTemplate_contains_nocase: String
    tokenTemplate_ends_with: String
    tokenTemplate_ends_with_nocase: String
    tokenTemplate_gt: String
    tokenTemplate_gte: String
    tokenTemplate_in: [String!]
    tokenTemplate_lt: String
    tokenTemplate_lte: String
    tokenTemplate_not: String
    tokenTemplate_not_contains: String
    tokenTemplate_not_contains_nocase: String
    tokenTemplate_not_ends_with: String
    tokenTemplate_not_ends_with_nocase: String
    tokenTemplate_not_in: [String!]
    tokenTemplate_not_starts_with: String
    tokenTemplate_not_starts_with_nocase: String
    tokenTemplate_starts_with: String
    tokenTemplate_starts_with_nocase: String
    traits_: TraitValue_filter
    worldEntity: String
    worldEntity_: WorldEntity_filter
    worldEntity_contains: String
    worldEntity_contains_nocase: String
    worldEntity_ends_with: String
    worldEntity_ends_with_nocase: String
    worldEntity_gt: String
    worldEntity_gte: String
    worldEntity_in: [String!]
    worldEntity_lt: String
    worldEntity_lte: String
    worldEntity_not: String
    worldEntity_not_contains: String
    worldEntity_not_contains_nocase: String
    worldEntity_not_ends_with: String
    worldEntity_not_ends_with_nocase: String
    worldEntity_not_in: [String!]
    worldEntity_not_starts_with: String
    worldEntity_not_starts_with_nocase: String
    worldEntity_starts_with: String
    worldEntity_starts_with_nocase: String
}

input HoldingMilestone_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [HoldingMilestone_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    loots: [String!]
    loots_: Loot_filter
    loots_contains: [String!]
    loots_contains_nocase: [String!]
    loots_not: [String!]
    loots_not_contains: [String!]
    loots_not_contains_nocase: [String!]
    milestoneIndex: Int
    milestoneIndex_gt: Int
    milestoneIndex_gte: Int
    milestoneIndex_in: [Int!]
    milestoneIndex_lt: Int
    milestoneIndex_lte: Int
    milestoneIndex_not: Int
    milestoneIndex_not_in: [Int!]
    or: [HoldingMilestone_filter]
    timeHeldSeconds: BigInt
    timeHeldSeconds_gt: BigInt
    timeHeldSeconds_gte: BigInt
    timeHeldSeconds_in: [BigInt!]
    timeHeldSeconds_lt: BigInt
    timeHeldSeconds_lte: BigInt
    timeHeldSeconds_not: BigInt
    timeHeldSeconds_not_in: [BigInt!]
    tokenContract: String
    tokenContract_: Contract_filter
    tokenContract_contains: String
    tokenContract_contains_nocase: String
    tokenContract_ends_with: String
    tokenContract_ends_with_nocase: String
    tokenContract_gt: String
    tokenContract_gte: String
    tokenContract_in: [String!]
    tokenContract_lt: String
    tokenContract_lte: String
    tokenContract_not: String
    tokenContract_not_contains: String
    tokenContract_not_contains_nocase: String
    tokenContract_not_ends_with: String
    tokenContract_not_ends_with_nocase: String
    tokenContract_not_in: [String!]
    tokenContract_not_starts_with: String
    tokenContract_not_starts_with_nocase: String
    tokenContract_starts_with: String
    tokenContract_starts_with_nocase: String
}

input LootSet_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [LootSet_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    loots: [String!]
    loots_: Loot_filter
    loots_contains: [String!]
    loots_contains_nocase: [String!]
    loots_not: [String!]
    loots_not_contains: [String!]
    loots_not_contains_nocase: [String!]
    or: [LootSet_filter]
}

input LootTable_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [LootTable_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    lootSets: [String!]
    lootSets_: LootSet_filter
    lootSets_contains: [String!]
    lootSets_contains_nocase: [String!]
    lootSets_not: [String!]
    lootSets_not_contains: [String!]
    lootSets_not_contains_nocase: [String!]
    maxSupply: [BigInt!]
    maxSupply_contains: [BigInt!]
    maxSupply_contains_nocase: [BigInt!]
    maxSupply_not: [BigInt!]
    maxSupply_not_contains: [BigInt!]
    maxSupply_not_contains_nocase: [BigInt!]
    mints: [BigInt!]
    mints_contains: [BigInt!]
    mints_contains_nocase: [BigInt!]
    mints_not: [BigInt!]
    mints_not_contains: [BigInt!]
    mints_not_contains_nocase: [BigInt!]
    or: [LootTable_filter]
    weights: [BigInt!]
    weights_contains: [BigInt!]
    weights_contains_nocase: [BigInt!]
    weights_not: [BigInt!]
    weights_not_contains: [BigInt!]
    weights_not_contains_nocase: [BigInt!]
}

input Loot_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    and: [Loot_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    lootId: BigInt
    lootId_gt: BigInt
    lootId_gte: BigInt
    lootId_in: [BigInt!]
    lootId_lt: BigInt
    lootId_lte: BigInt
    lootId_not: BigInt
    lootId_not_in: [BigInt!]
    lootType: String
    lootType_contains: String
    lootType_contains_nocase: String
    lootType_ends_with: String
    lootType_ends_with_nocase: String
    lootType_gt: String
    lootType_gte: String
    lootType_in: [String!]
    lootType_lt: String
    lootType_lte: String
    lootType_not: String
    lootType_not_contains: String
    lootType_not_contains_nocase: String
    lootType_not_ends_with: String
    lootType_not_ends_with_nocase: String
    lootType_not_in: [String!]
    lootType_not_starts_with: String
    lootType_not_starts_with_nocase: String
    lootType_starts_with: String
    lootType_starts_with_nocase: String
    or: [Loot_filter]
    tokenContract: String
    tokenContract_: Contract_filter
    tokenContract_contains: String
    tokenContract_contains_nocase: String
    tokenContract_ends_with: String
    tokenContract_ends_with_nocase: String
    tokenContract_gt: String
    tokenContract_gte: String
    tokenContract_in: [String!]
    tokenContract_lt: String
    tokenContract_lte: String
    tokenContract_not: String
    tokenContract_not_contains: String
    tokenContract_not_contains_nocase: String
    tokenContract_not_ends_with: String
    tokenContract_not_ends_with_nocase: String
    tokenContract_not_in: [String!]
    tokenContract_not_starts_with: String
    tokenContract_not_starts_with_nocase: String
    tokenContract_starts_with: String
    tokenContract_starts_with_nocase: String
}

input NFTClaimedMilestone_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [NFTClaimedMilestone_filter]
    claimed: Boolean
    claimedAt: BigInt
    claimedAt_gt: BigInt
    claimedAt_gte: BigInt
    claimedAt_in: [BigInt!]
    claimedAt_lt: BigInt
    claimedAt_lte: BigInt
    claimedAt_not: BigInt
    claimedAt_not_in: [BigInt!]
    claimed_in: [Boolean!]
    claimed_not: Boolean
    claimed_not_in: [Boolean!]
    holdingMilestone: String
    holdingMilestone_: HoldingMilestone_filter
    holdingMilestone_contains: String
    holdingMilestone_contains_nocase: String
    holdingMilestone_ends_with: String
    holdingMilestone_ends_with_nocase: String
    holdingMilestone_gt: String
    holdingMilestone_gte: String
    holdingMilestone_in: [String!]
    holdingMilestone_lt: String
    holdingMilestone_lte: String
    holdingMilestone_not: String
    holdingMilestone_not_contains: String
    holdingMilestone_not_contains_nocase: String
    holdingMilestone_not_ends_with: String
    holdingMilestone_not_ends_with_nocase: String
    holdingMilestone_not_in: [String!]
    holdingMilestone_not_starts_with: String
    holdingMilestone_not_starts_with_nocase: String
    holdingMilestone_starts_with: String
    holdingMilestone_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    milestoneIndex: Int
    milestoneIndex_gt: Int
    milestoneIndex_gte: Int
    milestoneIndex_in: [Int!]
    milestoneIndex_lt: Int
    milestoneIndex_lte: Int
    milestoneIndex_not: Int
    milestoneIndex_not_in: [Int!]
    nft: String
    nft_: NFT_filter
    nft_contains: String
    nft_contains_nocase: String
    nft_ends_with: String
    nft_ends_with_nocase: String
    nft_gt: String
    nft_gte: String
    nft_in: [String!]
    nft_lt: String
    nft_lte: String
    nft_not: String
    nft_not_contains: String
    nft_not_contains_nocase: String
    nft_not_ends_with: String
    nft_not_ends_with_nocase: String
    nft_not_in: [String!]
    nft_not_starts_with: String
    nft_not_starts_with_nocase: String
    nft_starts_with: String
    nft_starts_with_nocase: String
    or: [NFTClaimedMilestone_filter]
}

input NFT_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    actions_: TokenAction_filter
    and: [NFT_filter]
    animationUrl: String
    animationUrl_contains: String
    animationUrl_contains_nocase: String
    animationUrl_ends_with: String
    animationUrl_ends_with_nocase: String
    animationUrl_gt: String
    animationUrl_gte: String
    animationUrl_in: [String!]
    animationUrl_lt: String
    animationUrl_lte: String
    animationUrl_not: String
    animationUrl_not_contains: String
    animationUrl_not_contains_nocase: String
    animationUrl_not_ends_with: String
    animationUrl_not_ends_with_nocase: String
    animationUrl_not_in: [String!]
    animationUrl_not_starts_with: String
    animationUrl_not_starts_with_nocase: String
    animationUrl_starts_with: String
    animationUrl_starts_with_nocase: String
    attributes_: TokenAttribute_filter
    claimedMilestones_: NFTClaimedMilestone_filter
    contractAddress: String
    contractAddress_contains: String
    contractAddress_contains_nocase: String
    contractAddress_ends_with: String
    contractAddress_ends_with_nocase: String
    contractAddress_gt: String
    contractAddress_gte: String
    contractAddress_in: [String!]
    contractAddress_lt: String
    contractAddress_lte: String
    contractAddress_not: String
    contractAddress_not_contains: String
    contractAddress_not_contains_nocase: String
    contractAddress_not_ends_with: String
    contractAddress_not_ends_with_nocase: String
    contractAddress_not_in: [String!]
    contractAddress_not_starts_with: String
    contractAddress_not_starts_with_nocase: String
    contractAddress_starts_with: String
    contractAddress_starts_with_nocase: String
    description: String
    description_contains: String
    description_contains_nocase: String
    description_ends_with: String
    description_ends_with_nocase: String
    description_gt: String
    description_gte: String
    description_in: [String!]
    description_lt: String
    description_lte: String
    description_not: String
    description_not_contains: String
    description_not_contains_nocase: String
    description_not_ends_with: String
    description_not_ends_with_nocase: String
    description_not_in: [String!]
    description_not_starts_with: String
    description_not_starts_with_nocase: String
    description_starts_with: String
    description_starts_with_nocase: String
    events_: Event_filter
    externalUrl: String
    externalUrl_contains: String
    externalUrl_contains_nocase: String
    externalUrl_ends_with: String
    externalUrl_ends_with_nocase: String
    externalUrl_gt: String
    externalUrl_gte: String
    externalUrl_in: [String!]
    externalUrl_lt: String
    externalUrl_lte: String
    externalUrl_not: String
    externalUrl_not_contains: String
    externalUrl_not_contains_nocase: String
    externalUrl_not_ends_with: String
    externalUrl_not_ends_with_nocase: String
    externalUrl_not_in: [String!]
    externalUrl_not_starts_with: String
    externalUrl_not_starts_with_nocase: String
    externalUrl_starts_with: String
    externalUrl_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    iframeUrl: String
    iframeUrl_contains: String
    iframeUrl_contains_nocase: String
    iframeUrl_ends_with: String
    iframeUrl_ends_with_nocase: String
    iframeUrl_gt: String
    iframeUrl_gte: String
    iframeUrl_in: [String!]
    iframeUrl_lt: String
    iframeUrl_lte: String
    iframeUrl_not: String
    iframeUrl_not_contains: String
    iframeUrl_not_contains_nocase: String
    iframeUrl_not_ends_with: String
    iframeUrl_not_ends_with_nocase: String
    iframeUrl_not_in: [String!]
    iframeUrl_not_starts_with: String
    iframeUrl_not_starts_with_nocase: String
    iframeUrl_starts_with: String
    iframeUrl_starts_with_nocase: String
    imagePng1024: String
    imagePng1024_contains: String
    imagePng1024_contains_nocase: String
    imagePng1024_ends_with: String
    imagePng1024_ends_with_nocase: String
    imagePng1024_gt: String
    imagePng1024_gte: String
    imagePng1024_in: [String!]
    imagePng1024_lt: String
    imagePng1024_lte: String
    imagePng1024_not: String
    imagePng1024_not_contains: String
    imagePng1024_not_contains_nocase: String
    imagePng1024_not_ends_with: String
    imagePng1024_not_ends_with_nocase: String
    imagePng1024_not_in: [String!]
    imagePng1024_not_starts_with: String
    imagePng1024_not_starts_with_nocase: String
    imagePng1024_starts_with: String
    imagePng1024_starts_with_nocase: String
    imagePng2048: String
    imagePng2048_contains: String
    imagePng2048_contains_nocase: String
    imagePng2048_ends_with: String
    imagePng2048_ends_with_nocase: String
    imagePng2048_gt: String
    imagePng2048_gte: String
    imagePng2048_in: [String!]
    imagePng2048_lt: String
    imagePng2048_lte: String
    imagePng2048_not: String
    imagePng2048_not_contains: String
    imagePng2048_not_contains_nocase: String
    imagePng2048_not_ends_with: String
    imagePng2048_not_ends_with_nocase: String
    imagePng2048_not_in: [String!]
    imagePng2048_not_starts_with: String
    imagePng2048_not_starts_with_nocase: String
    imagePng2048_starts_with: String
    imagePng2048_starts_with_nocase: String
    imagePng256: String
    imagePng256_contains: String
    imagePng256_contains_nocase: String
    imagePng256_ends_with: String
    imagePng256_ends_with_nocase: String
    imagePng256_gt: String
    imagePng256_gte: String
    imagePng256_in: [String!]
    imagePng256_lt: String
    imagePng256_lte: String
    imagePng256_not: String
    imagePng256_not_contains: String
    imagePng256_not_contains_nocase: String
    imagePng256_not_ends_with: String
    imagePng256_not_ends_with_nocase: String
    imagePng256_not_in: [String!]
    imagePng256_not_starts_with: String
    imagePng256_not_starts_with_nocase: String
    imagePng256_starts_with: String
    imagePng256_starts_with_nocase: String
    imagePng512: String
    imagePng512_contains: String
    imagePng512_contains_nocase: String
    imagePng512_ends_with: String
    imagePng512_ends_with_nocase: String
    imagePng512_gt: String
    imagePng512_gte: String
    imagePng512_in: [String!]
    imagePng512_lt: String
    imagePng512_lte: String
    imagePng512_not: String
    imagePng512_not_contains: String
    imagePng512_not_contains_nocase: String
    imagePng512_not_ends_with: String
    imagePng512_not_ends_with_nocase: String
    imagePng512_not_in: [String!]
    imagePng512_not_starts_with: String
    imagePng512_not_starts_with_nocase: String
    imagePng512_starts_with: String
    imagePng512_starts_with_nocase: String
    imageSvg: String
    imageSvg_contains: String
    imageSvg_contains_nocase: String
    imageSvg_ends_with: String
    imageSvg_ends_with_nocase: String
    imageSvg_gt: String
    imageSvg_gte: String
    imageSvg_in: [String!]
    imageSvg_lt: String
    imageSvg_lte: String
    imageSvg_not: String
    imageSvg_not_contains: String
    imageSvg_not_contains_nocase: String
    imageSvg_not_ends_with: String
    imageSvg_not_ends_with_nocase: String
    imageSvg_not_in: [String!]
    imageSvg_not_starts_with: String
    imageSvg_not_starts_with_nocase: String
    imageSvg_starts_with: String
    imageSvg_starts_with_nocase: String
    imageUrl: String
    imageUrl_contains: String
    imageUrl_contains_nocase: String
    imageUrl_ends_with: String
    imageUrl_ends_with_nocase: String
    imageUrl_gt: String
    imageUrl_gte: String
    imageUrl_in: [String!]
    imageUrl_lt: String
    imageUrl_lte: String
    imageUrl_not: String
    imageUrl_not_contains: String
    imageUrl_not_contains_nocase: String
    imageUrl_not_ends_with: String
    imageUrl_not_ends_with_nocase: String
    imageUrl_not_in: [String!]
    imageUrl_not_starts_with: String
    imageUrl_not_starts_with_nocase: String
    imageUrl_starts_with: String
    imageUrl_starts_with_nocase: String
    lastEarnTimestamp: BigInt
    lastEarnTimestamp_gt: BigInt
    lastEarnTimestamp_gte: BigInt
    lastEarnTimestamp_in: [BigInt!]
    lastEarnTimestamp_lt: BigInt
    lastEarnTimestamp_lte: BigInt
    lastEarnTimestamp_not: BigInt
    lastEarnTimestamp_not_in: [BigInt!]
    lastEnergyAmount: BigInt
    lastEnergyAmount_gt: BigInt
    lastEnergyAmount_gte: BigInt
    lastEnergyAmount_in: [BigInt!]
    lastEnergyAmount_lt: BigInt
    lastEnergyAmount_lte: BigInt
    lastEnergyAmount_not: BigInt
    lastEnergyAmount_not_in: [BigInt!]
    lastEnergyEarnable: BigInt
    lastEnergyEarnable_gt: BigInt
    lastEnergyEarnable_gte: BigInt
    lastEnergyEarnable_in: [BigInt!]
    lastEnergyEarnable_lt: BigInt
    lastEnergyEarnable_lte: BigInt
    lastEnergyEarnable_not: BigInt
    lastEnergyEarnable_not_in: [BigInt!]
    lastEnergySpendTimestamp: BigInt
    lastEnergySpendTimestamp_gt: BigInt
    lastEnergySpendTimestamp_gte: BigInt
    lastEnergySpendTimestamp_in: [BigInt!]
    lastEnergySpendTimestamp_lt: BigInt
    lastEnergySpendTimestamp_lte: BigInt
    lastEnergySpendTimestamp_not: BigInt
    lastEnergySpendTimestamp_not_in: [BigInt!]
    lastTransfer: BigInt
    lastTransfer_gt: BigInt
    lastTransfer_gte: BigInt
    lastTransfer_in: [BigInt!]
    lastTransfer_lt: BigInt
    lastTransfer_lte: BigInt
    lastTransfer_not: BigInt
    lastTransfer_not_in: [BigInt!]
    locked: Boolean
    locked_in: [Boolean!]
    locked_not: Boolean
    locked_not_in: [Boolean!]
    minted: Boolean
    minted_in: [Boolean!]
    minted_not: Boolean
    minted_not_in: [Boolean!]
    modelGltfUrl: String
    modelGltfUrl_contains: String
    modelGltfUrl_contains_nocase: String
    modelGltfUrl_ends_with: String
    modelGltfUrl_ends_with_nocase: String
    modelGltfUrl_gt: String
    modelGltfUrl_gte: String
    modelGltfUrl_in: [String!]
    modelGltfUrl_lt: String
    modelGltfUrl_lte: String
    modelGltfUrl_not: String
    modelGltfUrl_not_contains: String
    modelGltfUrl_not_contains_nocase: String
    modelGltfUrl_not_ends_with: String
    modelGltfUrl_not_ends_with_nocase: String
    modelGltfUrl_not_in: [String!]
    modelGltfUrl_not_starts_with: String
    modelGltfUrl_not_starts_with_nocase: String
    modelGltfUrl_starts_with: String
    modelGltfUrl_starts_with_nocase: String
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    nftType: String
    nftType_contains: String
    nftType_contains_nocase: String
    nftType_ends_with: String
    nftType_ends_with_nocase: String
    nftType_gt: String
    nftType_gte: String
    nftType_in: [String!]
    nftType_lt: String
    nftType_lte: String
    nftType_not: String
    nftType_not_contains: String
    nftType_not_contains_nocase: String
    nftType_not_ends_with: String
    nftType_not_ends_with_nocase: String
    nftType_not_in: [String!]
    nftType_not_starts_with: String
    nftType_not_starts_with_nocase: String
    nftType_starts_with: String
    nftType_starts_with_nocase: String
    or: [NFT_filter]
    owner: String
    owner_: Account_filter
    owner_contains: String
    owner_contains_nocase: String
    owner_ends_with: String
    owner_ends_with_nocase: String
    owner_gt: String
    owner_gte: String
    owner_in: [String!]
    owner_lt: String
    owner_lte: String
    owner_not: String
    owner_not_contains: String
    owner_not_contains_nocase: String
    owner_not_ends_with: String
    owner_not_ends_with_nocase: String
    owner_not_in: [String!]
    owner_not_starts_with: String
    owner_not_starts_with_nocase: String
    owner_starts_with: String
    owner_starts_with_nocase: String
    tags: String
    tags_contains: String
    tags_contains_nocase: String
    tags_ends_with: String
    tags_ends_with_nocase: String
    tags_gt: String
    tags_gte: String
    tags_in: [String!]
    tags_lt: String
    tags_lte: String
    tags_not: String
    tags_not_contains: String
    tags_not_contains_nocase: String
    tags_not_ends_with: String
    tags_not_ends_with_nocase: String
    tags_not_in: [String!]
    tags_not_starts_with: String
    tags_not_starts_with_nocase: String
    tags_starts_with: String
    tags_starts_with_nocase: String
    tokenId: BigInt
    tokenId_gt: BigInt
    tokenId_gte: BigInt
    tokenId_in: [BigInt!]
    tokenId_lt: BigInt
    tokenId_lte: BigInt
    tokenId_not: BigInt
    tokenId_not_in: [BigInt!]
    tokenTemplate: String
    tokenTemplate_: TokenTemplate_filter
    tokenTemplate_contains: String
    tokenTemplate_contains_nocase: String
    tokenTemplate_ends_with: String
    tokenTemplate_ends_with_nocase: String
    tokenTemplate_gt: String
    tokenTemplate_gte: String
    tokenTemplate_in: [String!]
    tokenTemplate_lt: String
    tokenTemplate_lte: String
    tokenTemplate_not: String
    tokenTemplate_not_contains: String
    tokenTemplate_not_contains_nocase: String
    tokenTemplate_not_ends_with: String
    tokenTemplate_not_ends_with_nocase: String
    tokenTemplate_not_in: [String!]
    tokenTemplate_not_starts_with: String
    tokenTemplate_not_starts_with_nocase: String
    tokenTemplate_starts_with: String
    tokenTemplate_starts_with_nocase: String
    traits_: TraitValue_filter
    worldEntity: String
    worldEntity_: WorldEntity_filter
    worldEntity_contains: String
    worldEntity_contains_nocase: String
    worldEntity_ends_with: String
    worldEntity_ends_with_nocase: String
    worldEntity_gt: String
    worldEntity_gte: String
    worldEntity_in: [String!]
    worldEntity_lt: String
    worldEntity_lte: String
    worldEntity_not: String
    worldEntity_not_contains: String
    worldEntity_not_contains_nocase: String
    worldEntity_not_ends_with: String
    worldEntity_not_ends_with_nocase: String
    worldEntity_not_in: [String!]
    worldEntity_not_starts_with: String
    worldEntity_not_starts_with_nocase: String
    worldEntity_starts_with: String
    worldEntity_starts_with_nocase: String
}

input OperatorAccount_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    address: String
    address_contains: String
    address_contains_nocase: String
    address_ends_with: String
    address_ends_with_nocase: String
    address_gt: String
    address_gte: String
    address_in: [String!]
    address_lt: String
    address_lte: String
    address_not: String
    address_not_contains: String
    address_not_contains_nocase: String
    address_not_ends_with: String
    address_not_ends_with_nocase: String
    address_not_in: [String!]
    address_not_starts_with: String
    address_not_starts_with_nocase: String
    address_starts_with: String
    address_starts_with_nocase: String
    and: [OperatorAccount_filter]
    expiration: BigInt
    expiration_gt: BigInt
    expiration_gte: BigInt
    expiration_in: [BigInt!]
    expiration_lt: BigInt
    expiration_lte: BigInt
    expiration_not: BigInt
    expiration_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [OperatorAccount_filter]
    playerAccount: String
    playerAccount_: Account_filter
    playerAccount_contains: String
    playerAccount_contains_nocase: String
    playerAccount_ends_with: String
    playerAccount_ends_with_nocase: String
    playerAccount_gt: String
    playerAccount_gte: String
    playerAccount_in: [String!]
    playerAccount_lt: String
    playerAccount_lte: String
    playerAccount_not: String
    playerAccount_not_contains: String
    playerAccount_not_contains_nocase: String
    playerAccount_not_ends_with: String
    playerAccount_not_ends_with_nocase: String
    playerAccount_not_in: [String!]
    playerAccount_not_starts_with: String
    playerAccount_not_starts_with_nocase: String
    playerAccount_starts_with: String
    playerAccount_starts_with_nocase: String
}

input PirateStatsData_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [PirateStatsData_filter]
    energyGained: BigInt
    energyGained_gt: BigInt
    energyGained_gte: BigInt
    energyGained_in: [BigInt!]
    energyGained_lt: BigInt
    energyGained_lte: BigInt
    energyGained_not: BigInt
    energyGained_not_in: [BigInt!]
    energySpent: BigInt
    energySpent_gt: BigInt
    energySpent_gte: BigInt
    energySpent_in: [BigInt!]
    energySpent_lt: BigInt
    energySpent_lte: BigInt
    energySpent_not: BigInt
    energySpent_not_in: [BigInt!]
    goldMinted: BigInt
    goldMinted_gt: BigInt
    goldMinted_gte: BigInt
    goldMinted_in: [BigInt!]
    goldMinted_lt: BigInt
    goldMinted_lte: BigInt
    goldMinted_not: BigInt
    goldMinted_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    intervalStartAt: String
    intervalStartAt_contains: String
    intervalStartAt_contains_nocase: String
    intervalStartAt_ends_with: String
    intervalStartAt_ends_with_nocase: String
    intervalStartAt_gt: String
    intervalStartAt_gte: String
    intervalStartAt_in: [String!]
    intervalStartAt_lt: String
    intervalStartAt_lte: String
    intervalStartAt_not: String
    intervalStartAt_not_contains: String
    intervalStartAt_not_contains_nocase: String
    intervalStartAt_not_ends_with: String
    intervalStartAt_not_ends_with_nocase: String
    intervalStartAt_not_in: [String!]
    intervalStartAt_not_starts_with: String
    intervalStartAt_not_starts_with_nocase: String
    intervalStartAt_starts_with: String
    intervalStartAt_starts_with_nocase: String
    intervalType: StatsIntervalType
    intervalType_in: [StatsIntervalType!]
    intervalType_not: StatsIntervalType
    intervalType_not_in: [StatsIntervalType!]
    nft: String
    nft_: NFT_filter
    nft_contains: String
    nft_contains_nocase: String
    nft_ends_with: String
    nft_ends_with_nocase: String
    nft_gt: String
    nft_gte: String
    nft_in: [String!]
    nft_lt: String
    nft_lte: String
    nft_not: String
    nft_not_contains: String
    nft_not_contains_nocase: String
    nft_not_ends_with: String
    nft_not_ends_with_nocase: String
    nft_not_in: [String!]
    nft_not_starts_with: String
    nft_not_starts_with_nocase: String
    nft_starts_with: String
    nft_starts_with_nocase: String
    or: [PirateStatsData_filter]
    questsCompleted: Int
    questsCompleted_gt: Int
    questsCompleted_gte: Int
    questsCompleted_in: [Int!]
    questsCompleted_lt: Int
    questsCompleted_lte: Int
    questsCompleted_not: Int
    questsCompleted_not_in: [Int!]
    questsFailed: Int
    questsFailed_gt: Int
    questsFailed_gte: Int
    questsFailed_in: [Int!]
    questsFailed_lt: Int
    questsFailed_lte: Int
    questsFailed_not: Int
    questsFailed_not_in: [Int!]
    questsStarted: Int
    questsStarted_gt: Int
    questsStarted_gte: Int
    questsStarted_in: [Int!]
    questsStarted_lt: Int
    questsStarted_lte: Int
    questsStarted_not: Int
    questsStarted_not_in: [Int!]
    questsSucceeded: Int
    questsSucceeded_gt: Int
    questsSucceeded_gte: Int
    questsSucceeded_in: [Int!]
    questsSucceeded_lt: Int
    questsSucceeded_lte: Int
    questsSucceeded_not: Int
    questsSucceeded_not_in: [Int!]
}

input QuestInput_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [QuestInput_filter]
    consumable: Boolean
    consumable_in: [Boolean!]
    consumable_not: Boolean
    consumable_not_in: [Boolean!]
    energyRequired: BigInt
    energyRequired_gt: BigInt
    energyRequired_gte: BigInt
    energyRequired_in: [BigInt!]
    energyRequired_lt: BigInt
    energyRequired_lte: BigInt
    energyRequired_not: BigInt
    energyRequired_not_in: [BigInt!]
    failureBurnProbability: BigInt
    failureBurnProbability_gt: BigInt
    failureBurnProbability_gte: BigInt
    failureBurnProbability_in: [BigInt!]
    failureBurnProbability_lt: BigInt
    failureBurnProbability_lte: BigInt
    failureBurnProbability_not: BigInt
    failureBurnProbability_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [QuestInput_filter]
    required: Boolean
    required_in: [Boolean!]
    required_not: Boolean
    required_not_in: [Boolean!]
    successBurnProbability: BigInt
    successBurnProbability_gt: BigInt
    successBurnProbability_gte: BigInt
    successBurnProbability_in: [BigInt!]
    successBurnProbability_lt: BigInt
    successBurnProbability_lte: BigInt
    successBurnProbability_not: BigInt
    successBurnProbability_not_in: [BigInt!]
    tokenPointer: String
    tokenPointer_: TokenPointer_filter
    tokenPointer_contains: String
    tokenPointer_contains_nocase: String
    tokenPointer_ends_with: String
    tokenPointer_ends_with_nocase: String
    tokenPointer_gt: String
    tokenPointer_gte: String
    tokenPointer_in: [String!]
    tokenPointer_lt: String
    tokenPointer_lte: String
    tokenPointer_not: String
    tokenPointer_not_contains: String
    tokenPointer_not_contains_nocase: String
    tokenPointer_not_ends_with: String
    tokenPointer_not_ends_with_nocase: String
    tokenPointer_not_in: [String!]
    tokenPointer_not_starts_with: String
    tokenPointer_not_starts_with_nocase: String
    tokenPointer_starts_with: String
    tokenPointer_starts_with_nocase: String
    traitChecks: [String!]
    traitChecks_: TraitCheck_filter
    traitChecks_contains: [String!]
    traitChecks_contains_nocase: [String!]
    traitChecks_not: [String!]
    traitChecks_not_contains: [String!]
    traitChecks_not_contains_nocase: [String!]
    xpEarnedPercent: BigInt
    xpEarnedPercent_gt: BigInt
    xpEarnedPercent_gte: BigInt
    xpEarnedPercent_in: [BigInt!]
    xpEarnedPercent_lt: BigInt
    xpEarnedPercent_lte: BigInt
    xpEarnedPercent_not: BigInt
    xpEarnedPercent_not_in: [BigInt!]
}

input Quest_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [Quest_filter]
    baseSuccessProbability: BigInt
    baseSuccessProbability_gt: BigInt
    baseSuccessProbability_gte: BigInt
    baseSuccessProbability_in: [BigInt!]
    baseSuccessProbability_lt: BigInt
    baseSuccessProbability_lte: BigInt
    baseSuccessProbability_not: BigInt
    baseSuccessProbability_not_in: [BigInt!]
    cooldownSeconds: BigInt
    cooldownSeconds_gt: BigInt
    cooldownSeconds_gte: BigInt
    cooldownSeconds_in: [BigInt!]
    cooldownSeconds_lt: BigInt
    cooldownSeconds_lte: BigInt
    cooldownSeconds_not: BigInt
    cooldownSeconds_not_in: [BigInt!]
    enabled: Boolean
    enabled_in: [Boolean!]
    enabled_not: Boolean
    enabled_not_in: [Boolean!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    inputs: [String!]
    inputs_: QuestInput_filter
    inputs_contains: [String!]
    inputs_contains_nocase: [String!]
    inputs_not: [String!]
    inputs_not_contains: [String!]
    inputs_not_contains_nocase: [String!]
    loots: [String!]
    loots_: Loot_filter
    loots_contains: [String!]
    loots_contains_nocase: [String!]
    loots_not: [String!]
    loots_not_contains: [String!]
    loots_not_contains_nocase: [String!]
    maxCompletions: BigInt
    maxCompletions_gt: BigInt
    maxCompletions_gte: BigInt
    maxCompletions_in: [BigInt!]
    maxCompletions_lt: BigInt
    maxCompletions_lte: BigInt
    maxCompletions_not: BigInt
    maxCompletions_not_in: [BigInt!]
    or: [Quest_filter]
    sortIndex: BigInt
    sortIndex_gt: BigInt
    sortIndex_gte: BigInt
    sortIndex_in: [BigInt!]
    sortIndex_lt: BigInt
    sortIndex_lte: BigInt
    sortIndex_not: BigInt
    sortIndex_not_in: [BigInt!]
    successXp: BigInt
    successXp_gt: BigInt
    successXp_gte: BigInt
    successXp_in: [BigInt!]
    successXp_lt: BigInt
    successXp_lte: BigInt
    successXp_not: BigInt
    successXp_not_in: [BigInt!]
    totalCompleted: Int
    totalCompleted_gt: Int
    totalCompleted_gte: Int
    totalCompleted_in: [Int!]
    totalCompleted_lt: Int
    totalCompleted_lte: Int
    totalCompleted_not: Int
    totalCompleted_not_in: [Int!]
    totalFailed: Int
    totalFailed_gt: Int
    totalFailed_gte: Int
    totalFailed_in: [Int!]
    totalFailed_lt: Int
    totalFailed_lte: Int
    totalFailed_not: Int
    totalFailed_not_in: [Int!]
    totalStarted: Int
    totalStarted_gt: Int
    totalStarted_gte: Int
    totalStarted_in: [Int!]
    totalStarted_lt: Int
    totalStarted_lte: Int
    totalStarted_not: Int
    totalStarted_not_in: [Int!]
    totalSucceeded: Int
    totalSucceeded_gt: Int
    totalSucceeded_gte: Int
    totalSucceeded_in: [Int!]
    totalSucceeded_lt: Int
    totalSucceeded_lte: Int
    totalSucceeded_not: Int
    totalSucceeded_not_in: [Int!]
}

input RecipeDefinition_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [RecipeDefinition_filter]
    baseSuccessProbability: BigInt
    baseSuccessProbability_gt: BigInt
    baseSuccessProbability_gte: BigInt
    baseSuccessProbability_in: [BigInt!]
    baseSuccessProbability_lt: BigInt
    baseSuccessProbability_lte: BigInt
    baseSuccessProbability_not: BigInt
    baseSuccessProbability_not_in: [BigInt!]
    cooldownSeconds: BigInt
    cooldownSeconds_gt: BigInt
    cooldownSeconds_gte: BigInt
    cooldownSeconds_in: [BigInt!]
    cooldownSeconds_lt: BigInt
    cooldownSeconds_lte: BigInt
    cooldownSeconds_not: BigInt
    cooldownSeconds_not_in: [BigInt!]
    enabled: Boolean
    enabled_in: [Boolean!]
    enabled_not: Boolean
    enabled_not_in: [Boolean!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    inputs: [String!]
    inputs_: RecipeInput_filter
    inputs_contains: [String!]
    inputs_contains_nocase: [String!]
    inputs_not: [String!]
    inputs_not_contains: [String!]
    inputs_not_contains_nocase: [String!]
    loots: [String!]
    loots_: Loot_filter
    loots_contains: [String!]
    loots_contains_nocase: [String!]
    loots_not: [String!]
    loots_not_contains: [String!]
    loots_not_contains_nocase: [String!]
    maxCompletions: BigInt
    maxCompletions_gt: BigInt
    maxCompletions_gte: BigInt
    maxCompletions_in: [BigInt!]
    maxCompletions_lt: BigInt
    maxCompletions_lte: BigInt
    maxCompletions_not: BigInt
    maxCompletions_not_in: [BigInt!]
    or: [RecipeDefinition_filter]
    sortIndex: BigInt
    sortIndex_gt: BigInt
    sortIndex_gte: BigInt
    sortIndex_in: [BigInt!]
    sortIndex_lt: BigInt
    sortIndex_lte: BigInt
    sortIndex_not: BigInt
    sortIndex_not_in: [BigInt!]
    successXp: BigInt
    successXp_gt: BigInt
    successXp_gte: BigInt
    successXp_in: [BigInt!]
    successXp_lt: BigInt
    successXp_lte: BigInt
    successXp_not: BigInt
    successXp_not_in: [BigInt!]
    totalCompleted: BigInt
    totalCompleted_gt: BigInt
    totalCompleted_gte: BigInt
    totalCompleted_in: [BigInt!]
    totalCompleted_lt: BigInt
    totalCompleted_lte: BigInt
    totalCompleted_not: BigInt
    totalCompleted_not_in: [BigInt!]
    totalFailed: BigInt
    totalFailed_gt: BigInt
    totalFailed_gte: BigInt
    totalFailed_in: [BigInt!]
    totalFailed_lt: BigInt
    totalFailed_lte: BigInt
    totalFailed_not: BigInt
    totalFailed_not_in: [BigInt!]
    totalStarted: BigInt
    totalStarted_gt: BigInt
    totalStarted_gte: BigInt
    totalStarted_in: [BigInt!]
    totalStarted_lt: BigInt
    totalStarted_lte: BigInt
    totalStarted_not: BigInt
    totalStarted_not_in: [BigInt!]
    totalSucceeded: BigInt
    totalSucceeded_gt: BigInt
    totalSucceeded_gte: BigInt
    totalSucceeded_in: [BigInt!]
    totalSucceeded_lt: BigInt
    totalSucceeded_lte: BigInt
    totalSucceeded_not: BigInt
    totalSucceeded_not_in: [BigInt!]
}

input RecipeInput_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [RecipeInput_filter]
    consumable: Boolean
    consumable_in: [Boolean!]
    consumable_not: Boolean
    consumable_not_in: [Boolean!]
    failureBurnProbability: BigInt
    failureBurnProbability_gt: BigInt
    failureBurnProbability_gte: BigInt
    failureBurnProbability_in: [BigInt!]
    failureBurnProbability_lt: BigInt
    failureBurnProbability_lte: BigInt
    failureBurnProbability_not: BigInt
    failureBurnProbability_not_in: [BigInt!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [RecipeInput_filter]
    required: Boolean
    required_in: [Boolean!]
    required_not: Boolean
    required_not_in: [Boolean!]
    successBurnProbability: BigInt
    successBurnProbability_gt: BigInt
    successBurnProbability_gte: BigInt
    successBurnProbability_in: [BigInt!]
    successBurnProbability_lt: BigInt
    successBurnProbability_lte: BigInt
    successBurnProbability_not: BigInt
    successBurnProbability_not_in: [BigInt!]
    tokenPointer: String
    tokenPointer_: TokenPointer_filter
    tokenPointer_contains: String
    tokenPointer_contains_nocase: String
    tokenPointer_ends_with: String
    tokenPointer_ends_with_nocase: String
    tokenPointer_gt: String
    tokenPointer_gte: String
    tokenPointer_in: [String!]
    tokenPointer_lt: String
    tokenPointer_lte: String
    tokenPointer_not: String
    tokenPointer_not_contains: String
    tokenPointer_not_contains_nocase: String
    tokenPointer_not_ends_with: String
    tokenPointer_not_ends_with_nocase: String
    tokenPointer_not_in: [String!]
    tokenPointer_not_starts_with: String
    tokenPointer_not_starts_with_nocase: String
    tokenPointer_starts_with: String
    tokenPointer_starts_with_nocase: String
    traitChecks: [String!]
    traitChecks_: TraitCheck_filter
    traitChecks_contains: [String!]
    traitChecks_contains_nocase: [String!]
    traitChecks_not: [String!]
    traitChecks_not_contains: [String!]
    traitChecks_not_contains_nocase: [String!]
    xpEarnedPercent: BigInt
    xpEarnedPercent_gt: BigInt
    xpEarnedPercent_gte: BigInt
    xpEarnedPercent_in: [BigInt!]
    xpEarnedPercent_lt: BigInt
    xpEarnedPercent_lte: BigInt
    xpEarnedPercent_not: BigInt
    xpEarnedPercent_not_in: [BigInt!]
}

input System_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [System_filter]
    contract: String
    contract_: Contract_filter
    contract_contains: String
    contract_contains_nocase: String
    contract_ends_with: String
    contract_ends_with_nocase: String
    contract_gt: String
    contract_gte: String
    contract_in: [String!]
    contract_lt: String
    contract_lte: String
    contract_not: String
    contract_not_contains: String
    contract_not_contains_nocase: String
    contract_not_ends_with: String
    contract_not_ends_with_nocase: String
    contract_not_in: [String!]
    contract_not_starts_with: String
    contract_not_starts_with_nocase: String
    contract_starts_with: String
    contract_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [System_filter]
    worldEntity: String
    worldEntity_: WorldEntity_filter
    worldEntity_contains: String
    worldEntity_contains_nocase: String
    worldEntity_ends_with: String
    worldEntity_ends_with_nocase: String
    worldEntity_gt: String
    worldEntity_gte: String
    worldEntity_in: [String!]
    worldEntity_lt: String
    worldEntity_lte: String
    worldEntity_not: String
    worldEntity_not_contains: String
    worldEntity_not_contains_nocase: String
    worldEntity_not_ends_with: String
    worldEntity_not_ends_with_nocase: String
    worldEntity_not_in: [String!]
    worldEntity_not_starts_with: String
    worldEntity_not_starts_with_nocase: String
    worldEntity_starts_with: String
    worldEntity_starts_with_nocase: String
}

input TokenActionContract_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [TokenActionContract_filter]
    contractAddress: String
    contractAddress_contains: String
    contractAddress_contains_nocase: String
    contractAddress_ends_with: String
    contractAddress_ends_with_nocase: String
    contractAddress_gt: String
    contractAddress_gte: String
    contractAddress_in: [String!]
    contractAddress_lt: String
    contractAddress_lte: String
    contractAddress_not: String
    contractAddress_not_contains: String
    contractAddress_not_contains_nocase: String
    contractAddress_not_ends_with: String
    contractAddress_not_ends_with_nocase: String
    contractAddress_not_in: [String!]
    contractAddress_not_starts_with: String
    contractAddress_not_starts_with_nocase: String
    contractAddress_starts_with: String
    contractAddress_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    or: [TokenActionContract_filter]
}

input TokenAction_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    actionId: String
    actionId_contains: String
    actionId_contains_nocase: String
    actionId_ends_with: String
    actionId_ends_with_nocase: String
    actionId_gt: String
    actionId_gte: String
    actionId_in: [String!]
    actionId_lt: String
    actionId_lte: String
    actionId_not: String
    actionId_not_contains: String
    actionId_not_contains_nocase: String
    actionId_not_ends_with: String
    actionId_not_ends_with_nocase: String
    actionId_not_in: [String!]
    actionId_not_starts_with: String
    actionId_not_starts_with_nocase: String
    actionId_starts_with: String
    actionId_starts_with_nocase: String
    and: [TokenAction_filter]
    consumable: Boolean
    consumable_in: [Boolean!]
    consumable_not: Boolean
    consumable_not_in: [Boolean!]
    cooldownSeconds: BigInt
    cooldownSeconds_gt: BigInt
    cooldownSeconds_gte: BigInt
    cooldownSeconds_in: [BigInt!]
    cooldownSeconds_lt: BigInt
    cooldownSeconds_lte: BigInt
    cooldownSeconds_not: BigInt
    cooldownSeconds_not_in: [BigInt!]
    enabled: Boolean
    enabled_in: [Boolean!]
    enabled_not: Boolean
    enabled_not_in: [Boolean!]
    gameItem: String
    gameItem_: GameItem_filter
    gameItem_contains: String
    gameItem_contains_nocase: String
    gameItem_ends_with: String
    gameItem_ends_with_nocase: String
    gameItem_gt: String
    gameItem_gte: String
    gameItem_in: [String!]
    gameItem_lt: String
    gameItem_lte: String
    gameItem_not: String
    gameItem_not_contains: String
    gameItem_not_contains_nocase: String
    gameItem_not_ends_with: String
    gameItem_not_ends_with_nocase: String
    gameItem_not_in: [String!]
    gameItem_not_starts_with: String
    gameItem_not_starts_with_nocase: String
    gameItem_starts_with: String
    gameItem_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    nft: String
    nft_: NFT_filter
    nft_contains: String
    nft_contains_nocase: String
    nft_ends_with: String
    nft_ends_with_nocase: String
    nft_gt: String
    nft_gte: String
    nft_in: [String!]
    nft_lt: String
    nft_lte: String
    nft_not: String
    nft_not_contains: String
    nft_not_contains_nocase: String
    nft_not_ends_with: String
    nft_not_ends_with_nocase: String
    nft_not_in: [String!]
    nft_not_starts_with: String
    nft_not_starts_with_nocase: String
    nft_starts_with: String
    nft_starts_with_nocase: String
    or: [TokenAction_filter]
}

input TokenAttribute_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [TokenAttribute_filter]
    gameItem: String
    gameItem_: GameItem_filter
    gameItem_contains: String
    gameItem_contains_nocase: String
    gameItem_ends_with: String
    gameItem_ends_with_nocase: String
    gameItem_gt: String
    gameItem_gte: String
    gameItem_in: [String!]
    gameItem_lt: String
    gameItem_lte: String
    gameItem_not: String
    gameItem_not_contains: String
    gameItem_not_contains_nocase: String
    gameItem_not_ends_with: String
    gameItem_not_ends_with_nocase: String
    gameItem_not_in: [String!]
    gameItem_not_starts_with: String
    gameItem_not_starts_with_nocase: String
    gameItem_starts_with: String
    gameItem_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    nft: String
    nft_: NFT_filter
    nft_contains: String
    nft_contains_nocase: String
    nft_ends_with: String
    nft_ends_with_nocase: String
    nft_gt: String
    nft_gte: String
    nft_in: [String!]
    nft_lt: String
    nft_lte: String
    nft_not: String
    nft_not_contains: String
    nft_not_contains_nocase: String
    nft_not_ends_with: String
    nft_not_ends_with_nocase: String
    nft_not_in: [String!]
    nft_not_starts_with: String
    nft_not_starts_with_nocase: String
    nft_starts_with: String
    nft_starts_with_nocase: String
    or: [TokenAttribute_filter]
    tokenTemplate: String
    tokenTemplate_: TokenTemplate_filter
    tokenTemplate_contains: String
    tokenTemplate_contains_nocase: String
    tokenTemplate_ends_with: String
    tokenTemplate_ends_with_nocase: String
    tokenTemplate_gt: String
    tokenTemplate_gte: String
    tokenTemplate_in: [String!]
    tokenTemplate_lt: String
    tokenTemplate_lte: String
    tokenTemplate_not: String
    tokenTemplate_not_contains: String
    tokenTemplate_not_contains_nocase: String
    tokenTemplate_not_ends_with: String
    tokenTemplate_not_ends_with_nocase: String
    tokenTemplate_not_in: [String!]
    tokenTemplate_not_starts_with: String
    tokenTemplate_not_starts_with_nocase: String
    tokenTemplate_starts_with: String
    tokenTemplate_starts_with_nocase: String
    value: String
    value_contains: String
    value_contains_nocase: String
    value_ends_with: String
    value_ends_with_nocase: String
    value_gt: String
    value_gte: String
    value_in: [String!]
    value_lt: String
    value_lte: String
    value_not: String
    value_not_contains: String
    value_not_contains_nocase: String
    value_not_ends_with: String
    value_not_ends_with_nocase: String
    value_not_in: [String!]
    value_not_starts_with: String
    value_not_starts_with_nocase: String
    value_starts_with: String
    value_starts_with_nocase: String
}

input TokenPointer_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    amount: BigInt
    amount_gt: BigInt
    amount_gte: BigInt
    amount_in: [BigInt!]
    amount_lt: BigInt
    amount_lte: BigInt
    amount_not: BigInt
    amount_not_in: [BigInt!]
    and: [TokenPointer_filter]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [TokenPointer_filter]
    tokenContract: String
    tokenContract_: Contract_filter
    tokenContract_contains: String
    tokenContract_contains_nocase: String
    tokenContract_ends_with: String
    tokenContract_ends_with_nocase: String
    tokenContract_gt: String
    tokenContract_gte: String
    tokenContract_in: [String!]
    tokenContract_lt: String
    tokenContract_lte: String
    tokenContract_not: String
    tokenContract_not_contains: String
    tokenContract_not_contains_nocase: String
    tokenContract_not_ends_with: String
    tokenContract_not_ends_with_nocase: String
    tokenContract_not_in: [String!]
    tokenContract_not_starts_with: String
    tokenContract_not_starts_with_nocase: String
    tokenContract_starts_with: String
    tokenContract_starts_with_nocase: String
    tokenId: BigInt
    tokenId_gt: BigInt
    tokenId_gte: BigInt
    tokenId_in: [BigInt!]
    tokenId_lt: BigInt
    tokenId_lte: BigInt
    tokenId_not: BigInt
    tokenId_not_in: [BigInt!]
    tokenType: String
    tokenType_contains: String
    tokenType_contains_nocase: String
    tokenType_ends_with: String
    tokenType_ends_with_nocase: String
    tokenType_gt: String
    tokenType_gte: String
    tokenType_in: [String!]
    tokenType_lt: String
    tokenType_lte: String
    tokenType_not: String
    tokenType_not_contains: String
    tokenType_not_contains_nocase: String
    tokenType_not_ends_with: String
    tokenType_not_ends_with_nocase: String
    tokenType_not_in: [String!]
    tokenType_not_starts_with: String
    tokenType_not_starts_with_nocase: String
    tokenType_starts_with: String
    tokenType_starts_with_nocase: String
}

input TokenTemplate_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [TokenTemplate_filter]
    animationUrl: String
    animationUrl_contains: String
    animationUrl_contains_nocase: String
    animationUrl_ends_with: String
    animationUrl_ends_with_nocase: String
    animationUrl_gt: String
    animationUrl_gte: String
    animationUrl_in: [String!]
    animationUrl_lt: String
    animationUrl_lte: String
    animationUrl_not: String
    animationUrl_not_contains: String
    animationUrl_not_contains_nocase: String
    animationUrl_not_ends_with: String
    animationUrl_not_ends_with_nocase: String
    animationUrl_not_in: [String!]
    animationUrl_not_starts_with: String
    animationUrl_not_starts_with_nocase: String
    animationUrl_starts_with: String
    animationUrl_starts_with_nocase: String
    attributes_: TokenAttribute_filter
    contractAddress: String
    contractAddress_contains: String
    contractAddress_contains_nocase: String
    contractAddress_ends_with: String
    contractAddress_ends_with_nocase: String
    contractAddress_gt: String
    contractAddress_gte: String
    contractAddress_in: [String!]
    contractAddress_lt: String
    contractAddress_lte: String
    contractAddress_not: String
    contractAddress_not_contains: String
    contractAddress_not_contains_nocase: String
    contractAddress_not_ends_with: String
    contractAddress_not_ends_with_nocase: String
    contractAddress_not_in: [String!]
    contractAddress_not_starts_with: String
    contractAddress_not_starts_with_nocase: String
    contractAddress_starts_with: String
    contractAddress_starts_with_nocase: String
    description: String
    description_contains: String
    description_contains_nocase: String
    description_ends_with: String
    description_ends_with_nocase: String
    description_gt: String
    description_gte: String
    description_in: [String!]
    description_lt: String
    description_lte: String
    description_not: String
    description_not_contains: String
    description_not_contains_nocase: String
    description_not_ends_with: String
    description_not_ends_with_nocase: String
    description_not_in: [String!]
    description_not_starts_with: String
    description_not_starts_with_nocase: String
    description_starts_with: String
    description_starts_with_nocase: String
    externalUrl: String
    externalUrl_contains: String
    externalUrl_contains_nocase: String
    externalUrl_ends_with: String
    externalUrl_ends_with_nocase: String
    externalUrl_gt: String
    externalUrl_gte: String
    externalUrl_in: [String!]
    externalUrl_lt: String
    externalUrl_lte: String
    externalUrl_not: String
    externalUrl_not_contains: String
    externalUrl_not_contains_nocase: String
    externalUrl_not_ends_with: String
    externalUrl_not_ends_with_nocase: String
    externalUrl_not_in: [String!]
    externalUrl_not_starts_with: String
    externalUrl_not_starts_with_nocase: String
    externalUrl_starts_with: String
    externalUrl_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    iframeUrl: String
    iframeUrl_contains: String
    iframeUrl_contains_nocase: String
    iframeUrl_ends_with: String
    iframeUrl_ends_with_nocase: String
    iframeUrl_gt: String
    iframeUrl_gte: String
    iframeUrl_in: [String!]
    iframeUrl_lt: String
    iframeUrl_lte: String
    iframeUrl_not: String
    iframeUrl_not_contains: String
    iframeUrl_not_contains_nocase: String
    iframeUrl_not_ends_with: String
    iframeUrl_not_ends_with_nocase: String
    iframeUrl_not_in: [String!]
    iframeUrl_not_starts_with: String
    iframeUrl_not_starts_with_nocase: String
    iframeUrl_starts_with: String
    iframeUrl_starts_with_nocase: String
    imageUrl: String
    imageUrl_contains: String
    imageUrl_contains_nocase: String
    imageUrl_ends_with: String
    imageUrl_ends_with_nocase: String
    imageUrl_gt: String
    imageUrl_gte: String
    imageUrl_in: [String!]
    imageUrl_lt: String
    imageUrl_lte: String
    imageUrl_not: String
    imageUrl_not_contains: String
    imageUrl_not_contains_nocase: String
    imageUrl_not_ends_with: String
    imageUrl_not_ends_with_nocase: String
    imageUrl_not_in: [String!]
    imageUrl_not_starts_with: String
    imageUrl_not_starts_with_nocase: String
    imageUrl_starts_with: String
    imageUrl_starts_with_nocase: String
    modelGltfUrl: String
    modelGltfUrl_contains: String
    modelGltfUrl_contains_nocase: String
    modelGltfUrl_ends_with: String
    modelGltfUrl_ends_with_nocase: String
    modelGltfUrl_gt: String
    modelGltfUrl_gte: String
    modelGltfUrl_in: [String!]
    modelGltfUrl_lt: String
    modelGltfUrl_lte: String
    modelGltfUrl_not: String
    modelGltfUrl_not_contains: String
    modelGltfUrl_not_contains_nocase: String
    modelGltfUrl_not_ends_with: String
    modelGltfUrl_not_ends_with_nocase: String
    modelGltfUrl_not_in: [String!]
    modelGltfUrl_not_starts_with: String
    modelGltfUrl_not_starts_with_nocase: String
    modelGltfUrl_starts_with: String
    modelGltfUrl_starts_with_nocase: String
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    or: [TokenTemplate_filter]
    tags: String
    tags_contains: String
    tags_contains_nocase: String
    tags_ends_with: String
    tags_ends_with_nocase: String
    tags_gt: String
    tags_gte: String
    tags_in: [String!]
    tags_lt: String
    tags_lte: String
    tags_not: String
    tags_not_contains: String
    tags_not_contains_nocase: String
    tags_not_ends_with: String
    tags_not_ends_with_nocase: String
    tags_not_in: [String!]
    tags_not_starts_with: String
    tags_not_starts_with_nocase: String
    tags_starts_with: String
    tags_starts_with_nocase: String
    tokenId: BigInt
    tokenId_gt: BigInt
    tokenId_gte: BigInt
    tokenId_in: [BigInt!]
    tokenId_lt: BigInt
    tokenId_lte: BigInt
    tokenId_not: BigInt
    tokenId_not_in: [BigInt!]
    traits_: TraitValue_filter
    worldEntity: String
    worldEntity_: WorldEntity_filter
    worldEntity_contains: String
    worldEntity_contains_nocase: String
    worldEntity_ends_with: String
    worldEntity_ends_with_nocase: String
    worldEntity_gt: String
    worldEntity_gte: String
    worldEntity_in: [String!]
    worldEntity_lt: String
    worldEntity_lte: String
    worldEntity_not: String
    worldEntity_not_contains: String
    worldEntity_not_contains_nocase: String
    worldEntity_not_ends_with: String
    worldEntity_not_ends_with_nocase: String
    worldEntity_not_in: [String!]
    worldEntity_not_starts_with: String
    worldEntity_not_starts_with_nocase: String
    worldEntity_starts_with: String
    worldEntity_starts_with_nocase: String
}

input TraitCheck_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [TraitCheck_filter]
    checkType: String
    checkType_contains: String
    checkType_contains_nocase: String
    checkType_ends_with: String
    checkType_ends_with_nocase: String
    checkType_gt: String
    checkType_gte: String
    checkType_in: [String!]
    checkType_lt: String
    checkType_lte: String
    checkType_not: String
    checkType_not_contains: String
    checkType_not_contains_nocase: String
    checkType_not_ends_with: String
    checkType_not_ends_with_nocase: String
    checkType_not_in: [String!]
    checkType_not_starts_with: String
    checkType_not_starts_with_nocase: String
    checkType_starts_with: String
    checkType_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [TraitCheck_filter]
    traitId: BigInt
    traitId_gt: BigInt
    traitId_gte: BigInt
    traitId_in: [BigInt!]
    traitId_lt: BigInt
    traitId_lte: BigInt
    traitId_not: BigInt
    traitId_not_in: [BigInt!]
    traitMetadata: String
    traitMetadata_: TraitMetadata_filter
    traitMetadata_contains: String
    traitMetadata_contains_nocase: String
    traitMetadata_ends_with: String
    traitMetadata_ends_with_nocase: String
    traitMetadata_gt: String
    traitMetadata_gte: String
    traitMetadata_in: [String!]
    traitMetadata_lt: String
    traitMetadata_lte: String
    traitMetadata_not: String
    traitMetadata_not_contains: String
    traitMetadata_not_contains_nocase: String
    traitMetadata_not_ends_with: String
    traitMetadata_not_ends_with_nocase: String
    traitMetadata_not_in: [String!]
    traitMetadata_not_starts_with: String
    traitMetadata_not_starts_with_nocase: String
    traitMetadata_starts_with: String
    traitMetadata_starts_with_nocase: String
    traitValue: BigInt
    traitValue_gt: BigInt
    traitValue_gte: BigInt
    traitValue_in: [BigInt!]
    traitValue_lt: BigInt
    traitValue_lte: BigInt
    traitValue_not: BigInt
    traitValue_not_in: [BigInt!]
}

input TraitMetadata_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [TraitMetadata_filter]
    behavior: TraitBehavior
    behavior_in: [TraitBehavior!]
    behavior_not: TraitBehavior
    behavior_not_in: [TraitBehavior!]
    hidden: Boolean
    hidden_in: [Boolean!]
    hidden_not: Boolean
    hidden_not_in: [Boolean!]
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    or: [TraitMetadata_filter]
    type: TraitDataType
    type_in: [TraitDataType!]
    type_not: TraitDataType
    type_not_in: [TraitDataType!]
}

input TraitValue_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [TraitValue_filter]
    gameItem: String
    gameItem_: GameItem_filter
    gameItem_contains: String
    gameItem_contains_nocase: String
    gameItem_ends_with: String
    gameItem_ends_with_nocase: String
    gameItem_gt: String
    gameItem_gte: String
    gameItem_in: [String!]
    gameItem_lt: String
    gameItem_lte: String
    gameItem_not: String
    gameItem_not_contains: String
    gameItem_not_contains_nocase: String
    gameItem_not_ends_with: String
    gameItem_not_ends_with_nocase: String
    gameItem_not_in: [String!]
    gameItem_not_starts_with: String
    gameItem_not_starts_with_nocase: String
    gameItem_starts_with: String
    gameItem_starts_with_nocase: String
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    metadata: String
    metadata_: TraitMetadata_filter
    metadata_contains: String
    metadata_contains_nocase: String
    metadata_ends_with: String
    metadata_ends_with_nocase: String
    metadata_gt: String
    metadata_gte: String
    metadata_in: [String!]
    metadata_lt: String
    metadata_lte: String
    metadata_not: String
    metadata_not_contains: String
    metadata_not_contains_nocase: String
    metadata_not_ends_with: String
    metadata_not_ends_with_nocase: String
    metadata_not_in: [String!]
    metadata_not_starts_with: String
    metadata_not_starts_with_nocase: String
    metadata_starts_with: String
    metadata_starts_with_nocase: String
    nft: String
    nft_: NFT_filter
    nft_contains: String
    nft_contains_nocase: String
    nft_ends_with: String
    nft_ends_with_nocase: String
    nft_gt: String
    nft_gte: String
    nft_in: [String!]
    nft_lt: String
    nft_lte: String
    nft_not: String
    nft_not_contains: String
    nft_not_contains_nocase: String
    nft_not_ends_with: String
    nft_not_ends_with_nocase: String
    nft_not_in: [String!]
    nft_not_starts_with: String
    nft_not_starts_with_nocase: String
    nft_starts_with: String
    nft_starts_with_nocase: String
    or: [TraitValue_filter]
    tokenContract: String
    tokenContract_: Contract_filter
    tokenContract_contains: String
    tokenContract_contains_nocase: String
    tokenContract_ends_with: String
    tokenContract_ends_with_nocase: String
    tokenContract_gt: String
    tokenContract_gte: String
    tokenContract_in: [String!]
    tokenContract_lt: String
    tokenContract_lte: String
    tokenContract_not: String
    tokenContract_not_contains: String
    tokenContract_not_contains_nocase: String
    tokenContract_not_ends_with: String
    tokenContract_not_ends_with_nocase: String
    tokenContract_not_in: [String!]
    tokenContract_not_starts_with: String
    tokenContract_not_starts_with_nocase: String
    tokenContract_starts_with: String
    tokenContract_starts_with_nocase: String
    tokenId: BigInt
    tokenId_gt: BigInt
    tokenId_gte: BigInt
    tokenId_in: [BigInt!]
    tokenId_lt: BigInt
    tokenId_lte: BigInt
    tokenId_not: BigInt
    tokenId_not_in: [BigInt!]
    tokenTemplate: String
    tokenTemplate_: TokenTemplate_filter
    tokenTemplate_contains: String
    tokenTemplate_contains_nocase: String
    tokenTemplate_ends_with: String
    tokenTemplate_ends_with_nocase: String
    tokenTemplate_gt: String
    tokenTemplate_gte: String
    tokenTemplate_in: [String!]
    tokenTemplate_lt: String
    tokenTemplate_lte: String
    tokenTemplate_not: String
    tokenTemplate_not_contains: String
    tokenTemplate_not_contains_nocase: String
    tokenTemplate_not_ends_with: String
    tokenTemplate_not_ends_with_nocase: String
    tokenTemplate_not_in: [String!]
    tokenTemplate_not_starts_with: String
    tokenTemplate_not_starts_with_nocase: String
    tokenTemplate_starts_with: String
    tokenTemplate_starts_with_nocase: String
    traitId: BigInt
    traitId_gt: BigInt
    traitId_gte: BigInt
    traitId_in: [BigInt!]
    traitId_lt: BigInt
    traitId_lte: BigInt
    traitId_not: BigInt
    traitId_not_in: [BigInt!]
    value: String
    value_contains: String
    value_contains_nocase: String
    value_ends_with: String
    value_ends_with_nocase: String
    value_gt: String
    value_gte: String
    value_in: [String!]
    value_lt: String
    value_lte: String
    value_not: String
    value_not_contains: String
    value_not_contains_nocase: String
    value_not_ends_with: String
    value_not_ends_with_nocase: String
    value_not_in: [String!]
    value_not_starts_with: String
    value_not_starts_with_nocase: String
    value_starts_with: String
    value_starts_with_nocase: String
    worldEntity: String
    worldEntity_: WorldEntity_filter
    worldEntity_contains: String
    worldEntity_contains_nocase: String
    worldEntity_ends_with: String
    worldEntity_ends_with_nocase: String
    worldEntity_gt: String
    worldEntity_gte: String
    worldEntity_in: [String!]
    worldEntity_lt: String
    worldEntity_lte: String
    worldEntity_not: String
    worldEntity_not_contains: String
    worldEntity_not_contains_nocase: String
    worldEntity_not_ends_with: String
    worldEntity_not_ends_with_nocase: String
    worldEntity_not_in: [String!]
    worldEntity_not_starts_with: String
    worldEntity_not_starts_with_nocase: String
    worldEntity_starts_with: String
    worldEntity_starts_with_nocase: String
}

input WorldEntityComponentValue_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    and: [WorldEntityComponentValue_filter]
    bytesValue: String
    bytesValue_contains: String
    bytesValue_contains_nocase: String
    bytesValue_ends_with: String
    bytesValue_ends_with_nocase: String
    bytesValue_gt: String
    bytesValue_gte: String
    bytesValue_in: [String!]
    bytesValue_lt: String
    bytesValue_lte: String
    bytesValue_not: String
    bytesValue_not_contains: String
    bytesValue_not_contains_nocase: String
    bytesValue_not_ends_with: String
    bytesValue_not_ends_with_nocase: String
    bytesValue_not_in: [String!]
    bytesValue_not_starts_with: String
    bytesValue_not_starts_with_nocase: String
    bytesValue_starts_with: String
    bytesValue_starts_with_nocase: String
    component: String
    component_: Component_filter
    component_contains: String
    component_contains_nocase: String
    component_ends_with: String
    component_ends_with_nocase: String
    component_gt: String
    component_gte: String
    component_in: [String!]
    component_lt: String
    component_lte: String
    component_not: String
    component_not_contains: String
    component_not_contains_nocase: String
    component_not_ends_with: String
    component_not_ends_with_nocase: String
    component_not_in: [String!]
    component_not_starts_with: String
    component_not_starts_with_nocase: String
    component_starts_with: String
    component_starts_with_nocase: String
    fields_: ComponentFieldValue_filter
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    or: [WorldEntityComponentValue_filter]
    worldEntity: String
    worldEntity_: WorldEntity_filter
    worldEntity_contains: String
    worldEntity_contains_nocase: String
    worldEntity_ends_with: String
    worldEntity_ends_with_nocase: String
    worldEntity_gt: String
    worldEntity_gte: String
    worldEntity_in: [String!]
    worldEntity_lt: String
    worldEntity_lte: String
    worldEntity_not: String
    worldEntity_not_contains: String
    worldEntity_not_contains_nocase: String
    worldEntity_not_ends_with: String
    worldEntity_not_ends_with_nocase: String
    worldEntity_not_in: [String!]
    worldEntity_not_starts_with: String
    worldEntity_not_starts_with_nocase: String
    worldEntity_starts_with: String
    worldEntity_starts_with_nocase: String
}

input WorldEntity_filter {
    "Filter for the block changed event."
    _change_block: BlockChangedFilter
    account_: Account_filter
    and: [WorldEntity_filter]
    component_: Component_filter
    components_: WorldEntityComponentValue_filter
    contract_: Contract_filter
    gameItem_: GameItem_filter
    id: ID
    id_gt: ID
    id_gte: ID
    id_in: [ID!]
    id_lt: ID
    id_lte: ID
    id_not: ID
    id_not_in: [ID!]
    name: String
    name_contains: String
    name_contains_nocase: String
    name_ends_with: String
    name_ends_with_nocase: String
    name_gt: String
    name_gte: String
    name_in: [String!]
    name_lt: String
    name_lte: String
    name_not: String
    name_not_contains: String
    name_not_contains_nocase: String
    name_not_ends_with: String
    name_not_ends_with_nocase: String
    name_not_in: [String!]
    name_not_starts_with: String
    name_not_starts_with_nocase: String
    name_starts_with: String
    name_starts_with_nocase: String
    nft_: NFT_filter
    or: [WorldEntity_filter]
    owner: String
    owner_: Account_filter
    owner_contains: String
    owner_contains_nocase: String
    owner_ends_with: String
    owner_ends_with_nocase: String
    owner_gt: String
    owner_gte: String
    owner_in: [String!]
    owner_lt: String
    owner_lte: String
    owner_not: String
    owner_not_contains: String
    owner_not_contains_nocase: String
    owner_not_ends_with: String
    owner_not_ends_with_nocase: String
    owner_not_in: [String!]
    owner_not_starts_with: String
    owner_not_starts_with_nocase: String
    owner_starts_with: String
    owner_starts_with_nocase: String
    system_: System_filter
    tokenTemplate_: TokenTemplate_filter
    traits_: TraitValue_filter
}
